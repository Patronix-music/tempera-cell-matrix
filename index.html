<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tempera Cell Matrix</title>
  <style>

    :root{
      --ctrlH: 40px;
      --bg0:#05070b;
      --bg1:#081225;
      --panel:rgba(255,255,255,0.05);
      --panel2:rgba(255,255,255,0.035);
      --border:rgba(255,255,255,0.10);
      --border2:rgba(255,255,255,0.18);
      --text:#e9f0fb;
      --fg: var(--text);
      --miniBtnH: calc(var(--ctrlH) - 8px);
      --muted:#9bb0cb;
      --accent:#7dd3fc;
      --accent2:#a78bfa;
      --good:#34d399;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 12px 40px rgba(0,0,0,0.55);
      --radius: 14px;
      --radius2: 12px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    html{ background: linear-gradient(180deg, var(--bg1), var(--bg0) 65%); }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      position: relative;
      background: transparent;
      overflow-x:auto;
    }

    /* Fixed background layer (prevents scrolling "bands" through translucent panels) */
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(900px 500px at 18% 0%, rgba(125, 211, 252, 0.12), transparent 60%),
        radial-gradient(900px 500px at 82% 0%, rgba(167, 139, 250, 0.12), transparent 60%),
        radial-gradient(1200px 800px at 50% 20%, rgba(255,255,255,0.03), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0) 65%);
      transform: translateZ(0);
    }


    header{
      position: sticky;
      top: 0;
      z-index: 10000;
      isolation: isolate;
      transform: translateZ(0);
      /* Opaquer header so content doesn't "bleed" through while scrolling (Firefox). */
      background-color: rgba(5,7,11,0.96);
      background-image: linear-gradient(180deg, rgba(8,18,37,0.96), rgba(5,7,11,0.94));
      border-bottom: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }

    .wrap{
      max-width: 1500px;
      margin: 0 auto;
      padding: 14px 16px 12px;
    }

    .topline{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 14px;
      flex-wrap: wrap;
    }

    h1{
      margin:0;
      font-size: 16px;
      letter-spacing: 0.2px;
      font-weight: 800;
    }

    .sub{
      margin-top: 6px;
      color: var(--muted);
      font-size: 11px;
      line-height: 1.35;
    }

    .spec{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
      display:inline-block;
      margin-right: 6px;
      margin-top: 6px;
    }

    .actions{
      display:flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items: flex-end;
      justify-content: space-between;
    }
    @media (min-width: 1320px){
      .actions{ flex-wrap: nowrap; }
    }


    /* Inline button group so buttons stay adjacent (e.g., Random 64 + Export/Import/Help) */
    .btnGroupInline{
      display:flex;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items: center;
    }

    /* Mini row under copyright: Enable audio + Stop/Clear */
    .copyrightTop .miniRow{
      display:flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items:center;
      justify-content:flex-end;
    }
    .actionsRow1{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:flex-end;
      flex-wrap: wrap;
    }

    .actionsRow2{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content: space-between;
      flex-wrap: wrap;
      width: 100%;
    }

    .actionsRow2 .rowLeft,
    .actionsRow2 .rowRight{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }
    .actionsRow2 .rowLeft{ justify-content:flex-start; }
    .actionsRow2 .rowRight{ justify-content:flex-end; margin-left:auto; }


    button{
      appearance:none;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      height: var(--ctrlH);
      padding: 0 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: transform 0.08s ease, border-color 0.15s ease, background 0.15s ease;
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
      font-weight: 750;
      letter-spacing: 0.2px;
      font-size: 11px;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      white-space: nowrap;
    }
    button:hover{ border-color: var(--border2); background: rgba(255,255,255,0.09); }
    button.dragover{ outline: 2px solid rgba(125,211,252,0.45); outline-offset: 2px; }

    button:active{ transform: translateY(1px); }
    button.secondary{ background: rgba(255,255,255,0.04); box-shadow:none; }
    button.good{ border-color: rgba(52,211,153,0.35); background: rgba(52,211,153,0.12); }
    
    button.pop{
      border-color: rgba(125,211,252,0.55);
      background: linear-gradient(180deg, rgba(125,211,252,0.22), rgba(167,139,250,0.16));
    }
    button.pop:hover{
      border-color: rgba(125,211,252,0.75);
      background: linear-gradient(180deg, rgba(125,211,252,0.28), rgba(167,139,250,0.20));
    }
    button.warn{ border-color: rgba(251,191,36,0.35); background: rgba(251,191,36,0.10); }
    button.danger{ border-color: rgba(251,113,133,0.35); background: rgba(251,113,133,0.10); }
    button.tiny{
      height: 30px;
      padding: 0 8px;
      border-radius: 9px;
      font-size: 11px;
      font-weight: 800;
      box-shadow:none;
    }

    .tog{
      display:flex;
      align-items:center;
      gap: 6px;
      height: var(--ctrlH);
      padding: 0 10px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(255,255,255,0.04);
      font-size: 11px;
      color: var(--muted);
      user-select:none;
    }
    .field label{ display:block; opacity:.95; font-size: 11px; color: var(--muted); letter-spacing: 0.2px; font-weight: 750; }

    /* Center labels for Safari-safe BPM/Beats controls */
    label[for="bpm"], label[for="beatsPerCell"]{ text-align:center; }
    #bpm, #beatsPerCell{ text-align:center; }
    .numCtl input{ text-align:center; }

    .field input, .field select{
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--text);
      border-radius: 10px;
      height: calc(var(--ctrlH) - 10px);
      padding: 0 8px;
      outline:none;
      font-size: 11px;
      min-width: 80px;
    }
    .field input[type="text"]{ min-width: 240px; }

    main{
      max-width: 1500px;
      margin: 0 auto;
      padding: 14px 16px 240px;
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .cols{
      display:grid;
      grid-template-columns: repeat(8, minmax(150px, 1fr));
      gap: 12px;
      align-items:start;
    }

    .col{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-width: 150px;
      container-type: inline-size;
    }

    .col.loaded{
      border-color: rgba(125,211,252,0.28);
    }

    .col.dragover{
      outline: 2px solid rgba(125,211,252,0.35);
      outline-offset: 2px;
      background: rgba(125,211,252,0.08);
    }

    .colHead{
      padding: 10px 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.05));
    }

    .colHeadRow{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
      flex-wrap: wrap; /* so col title stays visible when 8 columns are narrow */
    }

    .colName{
      display:flex;
      flex-direction:column;
      gap: 6px;
      min-width: 0;
      flex: 1 1 100%;
    }

    .colTitle{
      width: 100%;
      display:flex;
      align-items:center;
      gap: 6px;
      font-size: 11px;
      font-weight: 900;
      letter-spacing: 0.2px;
      color: var(--text);
      padding: 7px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
      user-select: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

        .colBtns{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px 10px;
      width: 100%;
      align-items: stretch;
    }
    .colBtns > button{ width: 100%; }
    .colBtns button{ width: 100%; }
    .colBtns button{
      width: 100%;
      justify-content: center;
    }

    .cells{
      padding: 10px;
      display:grid;
      grid-template-rows: repeat(8, 1fr);
      gap: 8px;
    }

    .cell{
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      background: var(--panel2);
      box-shadow: 0 10px 26px rgba(0,0,0,0.35);
      padding: 9px 9px 8px;
      cursor: default;
      position: relative;
      overflow:hidden;
      user-select:none;
    }

    
    /* Row accents (subtle strip per slice row; avoids full-width bands) */
    .cell::before{
      content:"";
      position:absolute;
      left:0;
      top:0;
      bottom:0;
      width:6px;
      border-radius: 14px 0 0 14px;
      background: rgba(255,255,255,0.06);
      opacity: 0.9;
      pointer-events:none;
    }
    .cells .cell:nth-child(1)::before{ background: linear-gradient(180deg, rgba(125,211,252,0.55), rgba(167,139,250,0.25)); }
    .cells .cell:nth-child(2)::before{ background: linear-gradient(180deg, rgba(167,139,250,0.50), rgba(125,211,252,0.20)); }
    .cells .cell:nth-child(3)::before{ background: linear-gradient(180deg, rgba(125,211,252,0.45), rgba(125,211,252,0.18)); }
    .cells .cell:nth-child(4)::before{ background: linear-gradient(180deg, rgba(52,211,153,0.45), rgba(125,211,252,0.18)); }
    .cells .cell:nth-child(5)::before{ background: linear-gradient(180deg, rgba(167,139,250,0.42), rgba(52,211,153,0.16)); }
    .cells .cell:nth-child(6)::before{ background: linear-gradient(180deg, rgba(125,211,252,0.40), rgba(255,255,255,0.12)); }
    .cells .cell:nth-child(7)::before{ background: linear-gradient(180deg, rgba(167,139,250,0.40), rgba(125,211,252,0.14)); }
    .cells .cell:nth-child(8)::before{ background: linear-gradient(180deg, rgba(255,255,255,0.28), rgba(125,211,252,0.10)); }

.cell.selected{
      border-color: rgba(167,139,250,0.55);
      box-shadow: inset 0 0 0 2px rgba(167,139,250,0.55), 0 16px 40px rgba(0,0,0,0.55);
    }

    
    /* Selected cell: hide left color stripe when inner purple highlight is active */
    .cell.selected::before{ opacity: 0; }
.cell.playing{
      border-color: rgba(52,211,153,0.65);
      /* match selected (purple) thickness: 2px inset highlight */
      box-shadow: inset 0 0 0 2px rgba(52,211,153,0.65), 0 16px 40px rgba(0,0,0,0.60);
    }

    .cell.dragSrc{
      opacity: .65;
      outline: 2px dashed rgba(167,139,250,0.55);
      outline-offset: 2px;
    }
    .cell.dragOver{
      outline: 2px solid rgba(125,211,252,0.45);
      outline-offset: 2px;
    }

    .cellTop{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      flex-wrap: nowrap;
      white-space: nowrap;
      gap: 4px;
      margin-bottom: 6px;
    }

    /* Tighten cell-top row so Slice / Fit / M / R always fit on one line (Safari-safe) */
    .cellTop .icons{
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex: 0 0 auto;
    }
    .cellTop .tag{
      /* Make Slice + Fit labels fit inside tiny 8×8 header cells (Safari-safe) */
      padding-left: 4px;
      padding-right: 4px;
      font-size: clamp(7px, 1.1vw, 9px);
      letter-spacing: -0.15px;
      flex: 0 1 auto;
      min-width: 0;
    }
    .cellTop .tag.mode{
      letter-spacing: -0.1px;
      max-width: 72px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Cell-top row: keep Slice / Fit / M / R on one line and same height */
    .cellTop .mode{ font-weight: inherit; font-size: 9px; }

    .cellTop .tag,
    .cellTop .icon{
      display:inline-flex;
      align-items:center;
      line-height: 1;
      height: 18px;
      padding-top: 0;
      padding-bottom: 0;
    }
    .cellTop .icon.mode{ height: 18px; }


.cellFile{
  font-size: 10px;
  color: var(--text);
  opacity: .92;
  margin: 0 0 2px;
  line-height: 1.15;
  display: flex;
  align-items: center;
  gap: 6px;
  min-width: 0;
}
.cellFile .cellFname{
  min-width: 0;
  flex: 1 1 auto;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.cellFile .cellCname{
  flex: 0 0 auto;
  white-space: nowrap;
  opacity: .95;
}
.cellTime{
  font-size: 10px;
  color: var(--muted);
  opacity: .95;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin: 0 0 6px;
  line-height: 1.1;
}
.gainBar{
  height: 4px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(0,0,0,0.22);
  overflow: hidden;
  margin-top: 4px;
}
.gainFill{
  height: 100%;
  width: 50%;
  background: linear-gradient(90deg, rgba(125,211,252,0.85), rgba(167,139,250,0.85));
}

    .cellTitle{
      min-width:0;
      display:flex;
      flex-direction:column;
      gap: 2px;
    }

    .cellTitle .line1{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content: space-between;
      min-width: 0;
    }

    .tag{
      font-family: var(--mono);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      color: var(--muted);
      white-space: nowrap;
    }

    .fname{
      font-size: 10px;
      color: var(--text);
      opacity: .92;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
      flex: 1 1 auto;
      min-width: 0;
      text-align: right;
    }

    .cellTitle .line2{
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .icons{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:nowrap;
      justify-content:flex-end;
      margin-left:auto;
    }
    
    .mode{ margin-left: 2px; }
.icon{
      font-family: var(--mono);
      font-weight: 900;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.20);
      color: var(--muted);
      opacity: .95;
    }
    .icon.on{
      border-color: rgba(52,211,153,0.35);
      color: rgba(233,240,251,0.95);
      background: rgba(52,211,153,0.12);
    }
    .icon.warn{
      border-color: rgba(251,191,36,0.35);
      background: rgba(251,191,36,0.10);
    }
    .tag.warn{
      border-color: rgba(251,191,36,0.35);
      background: rgba(251,191,36,0.10);
    }


    .wave{
      width: 100%;
      height: 36px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(0,0,0,0.28);
      display:block;
    }

    .cellBtns{
      display:flex;
      gap: 6px;
      margin-top: 7px;
      justify-content: space-between;
      align-items:center;
    }
    .cellBtns .left, .cellBtns .right{
      display:flex;
      gap: 6px;
      align-items:center;
      flex-wrap: wrap;
    }
    .cellBtns .left{ flex-wrap: nowrap; }
    .cellBtns .right{ flex-wrap: nowrap; }


    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--muted);
    }

    .muted{ color: var(--muted); }
    .helpCardTitle{ font-weight: 850; letter-spacing: 0.2px; font-size: 11px; margin-bottom: 6px; }


    /* Inspector */
    .inspector{
      position: sticky;
      bottom: 12px;
      z-index: 15;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      /* No backdrop-filter here: avoids Firefox "overlay band" artifacts. */
      background: linear-gradient(180deg, rgba(0,0,0,0.95), rgba(0,0,0,0.88));
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .inspHead{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .inspTitle{
      min-width: 280px;
      flex: 1;
    }

    .inspTitle .t{
      font-weight: 900;
      letter-spacing: 0.2px;
      font-size: 11px;
      margin:0;
    }
    .inspTitle .d{
      font-size: 11px;
      color: var(--muted);
      margin-top: 6px;
      line-height: 1.25;
    }

    .inspBody{
      padding: 8px 12px 10px;
      display:grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 8px;
      align-items:end;
    }

    .ctrl{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.03);
      border-radius: 14px;
      padding: 8px 9px;
      min-height: 74px;
      display: flex;
      flex-direction: column;
}

    .ctrl .lbl{
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 6px;
      display:flex;
      justify-content: space-between;
      gap: 8px;
    }
    .ctrl .lbl b{
      color: var(--text);
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 900;
    }
    /* Center the control vertically within the card (keeps label at top) */
    .ctrl > :last-child{ margin-top:auto; margin-bottom:auto; }


    .ctrl input[type="range"]{
      width: 100%;
    }

    .ctrl input[type="number"], .ctrl select{
      width: 100%;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.12);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 9px;
      outline:none;
      font-size: 11px;
    }

    .ctrlRow{
      display:flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items:center;
    }

    .chk{
      display:flex;
      align-items:center;
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
      user-select:none;
    }
    .chk input{ transform: translateY(1px); }

    /* Exports */

    .toast{

      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(20,22,28,0.92);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px 16px;
      font-size: 14px;
      color: var(--text);
      box-shadow: var(--shadow);
      max-width: min(900px, calc(100vw - 24px));
      display:none;
      z-index: 999;
    }
    .toast.show{ display:block; }

    @media (max-width: 1400px){
      .cols{ grid-template-columns: repeat(4, minmax(210px, 1fr)); }
      /* keep all 6 inspector control blocks on one line in 8×8 view */
      .inspBody{ grid-template-columns: repeat(6, minmax(0, 1fr)); gap: 8px; }
    }
    @media (max-width: 1050px){
      .inspBody{ grid-template-columns: repeat(3, minmax(140px, 1fr)); }
    }
    @media (max-width: 900px){
      .cols{ grid-template-columns: repeat(2, minmax(170px, 1fr)); }
      .field input[type="text"]{ min-width: 180px; }
    }
  
    /* ===== Download modal ===== */
    .dlModal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.62);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20000;
      padding: 16px;
    }
    .dlModal.show{ display:flex; }
    .dlCard{
      width: min(900px, 100%);
      max-height: min(82vh, 900px);
      overflow: auto;
      background: rgba(10,14,22,0.96);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      box-shadow: 0 20px 70px rgba(0,0,0,0.6);
      padding: 14px;
    }
    .dlHead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      padding: 6px 6px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      margin-bottom: 10px;
    }
    .dlTitle{
      font-weight: 850;
      letter-spacing: .2px;
      font-size: 14px;
    }
    .dlNote{
      color: rgba(210,225,255,0.75);
      font-size: 11px;
      line-height: 1.35;
      margin-top: 4px;
    }
    .dlBtns{
      display:flex;
      gap: 6px;
      flex-wrap: wrap;
      justify-content:flex-end;
    }
    .dlList{
      display:grid;
      grid-template-columns: repeat(2, minmax(220px, 1fr));
      gap: 8px;
      padding: 6px;
    }
    .dlItem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      min-width: 0;
    }
    .dlLabel{
      min-width: 0;
      display:flex;
      flex-direction:column;
      gap: 2px;
    }
    .dlLabel .a{
      font-weight: 800;
      font-size: 11px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .dlLabel .b{
      color: rgba(210,225,255,0.72);
      font-size: 11px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .dlItem a{
      text-decoration:none;
      font-weight: 850;
      font-size: 11px;
      color: var(--accent, #7dd3fc);
      border: 1px solid rgba(125,211,252,0.25);
      background: rgba(125,211,252,0.08);
      padding: 7px 9px;
      border-radius: 12px;
      white-space: nowrap;
      user-select:none;
    }
    @media (max-width: 700px){
      .dlList{ grid-template-columns: 1fr; }
    }


    /* colBtns responsive */
    @media (max-width: 1100px){
      .colBtns{ grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px 10px; }
    }
    @media (max-width: 720px){
      .colBtns{ grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px 10px; }
    }

  

    /* ===== Column buttons: force 2 per row (even spacing) ===== */
    .colHead .colBtns{
      display: grid !important;
      grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
      gap: 10px 10px !important;
      width: 100% !important;
      align-items: stretch !important;
    }
    .colHead .colBtns button{
      width: 100% !important;
      justify-content: center;
      min-width: 0;
    }

    /* ===== Help overlay ===== */
    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.62);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
      z-index: 30000;
    }
    .overlay.show{ display:flex; }
    .helpPanel{
      width: min(980px, calc(100vw - 24px));
      max-height: min(94vh, 980px);
      overflow: auto;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(7,12,20,0.96);
      box-shadow: 0 22px 70px rgba(0,0,0,0.65);
    }
.helpPanel{scrollbar-width:none;}
.helpPanel::-webkit-scrollbar{width:0;height:0;}
    .helpHead{
      position: sticky;
      top: 0;
      z-index: 1;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px 9px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      background: rgba(7,12,20,0.96);
    }
    .helpTitle{
      font-weight: 900;
      letter-spacing: 0.2px;
      font-size: 14px;
    }
    .helpClose{
      height: 32px;
      padding: 0 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      cursor:pointer;
      font-weight: 900;
    }
    .helpBody{
      padding: 8px;
      font-size: 11px;
      line-height: 1.28;
      color: rgba(233,240,251,0.96);
    }
    .helpGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
	    /* Release notes spans the full help grid width (two cards wide) and stays at the bottom. */
	    .helpCardRelease{ grid-column: 1 / -1; }
	    .helpCardRelease .helpList{ columns: 2; column-gap: 18px; }
	    .helpCardRelease .helpList li{ break-inside: avoid; }
	    .helpCardRelease p{ margin: 6px 0 8px; }

    .helpCard{
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.04);
      border-radius: 14px;
      padding: 7px 9px;
    }
    .helpCard h3{
      margin: 0 0 4px;
      font-size: 11px;
      font-weight: 850;
      letter-spacing: 0.15px;
    }
    .helpCard p{
      margin: 0 0 6px;
      color: rgba(155,176,203,0.95);
      font-size: 11px;
      line-height: 1.32;
    }
    .helpList{
      margin: 0;
      padding-left: 14px;
      color: rgba(155,176,203,0.98);
      font-size: 11px;
      line-height: 1.32;
    }
    .helpList li{ margin: 0 0 4px; }
    .helpTip{
      margin: 8px 0 2px;
      color: rgba(155,176,203,0.95);
      font-size: 11px;
      line-height: 1.28;
      text-align: left;
      padding-left: 0;
    }
.helpSnip{
      margin-top: 8px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.28);
      overflow:hidden;
    }
    .helpSnip svg{ display:block; width:100%; height:auto; }

    @media (max-width: 820px){
      .helpGrid{ grid-template-columns: 1fr; }
    }

        .copyrightTop{
      position: absolute;
      top: 10px;
      right: 14px;
      font-size: 11px;
      color: var(--muted);
      opacity: 0.95;
      text-align: right;
      display:flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 6px;
      z-index: 50;
    }
    .copyrightTop #copyrightText{
      pointer-events: none;
      white-space: nowrap;
    }
    .audioMini{
      box-sizing: border-box;
      height: var(--miniBtnH) !important;
      min-height: var(--miniBtnH) !important;
      padding: 0 10px !important;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.2px;
      line-height: var(--miniBtnH) !important;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* Number steppers (Safari-safe) */

/* v2.5.12: hide native number input spinners (Firefox + WebKit) */
input[type="number"]{
  -moz-appearance: textfield;   /* Firefox */
  appearance: textfield;        /* modern */
}
input[type="number"]::-webkit-outer-spin-button,
input[type="number"]::-webkit-inner-spin-button{
  -webkit-appearance: none;     /* Safari/Chrome */
  margin: 0;
}

    .numWrap{
      display:flex;
      align-items: stretch;
      gap: 6px;
    }
    .numBtn{
      width: 34px;
      min-width: 34px;
      height: calc(var(--ctrlH) - 10px);
      padding: 0;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      cursor: pointer;
      font-weight: 900;
      line-height: 1;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
    }
    .numBtn:hover{ border-color: var(--border2); background: rgba(255,255,255,0.09); }
    .numBtn:active{ transform: translateY(1px); }
    .field.numField input[type="number"]{
      width: 92px;
    }

    /* Inspector Info: keep row height aligned */
    #cellInfo{
  white-space: pre-line;      /* nieuwe regels tonen */
  overflow: visible;          /* niet afkappen */
  text-overflow: clip;
  overflow-wrap: anywhere;
  word-break: break-word;
  max-width: none;
  line-height: 1.25;
}

  
    /* Footer info can wrap (show full text) */
    .inspectorRow{ align-items: flex-start; }
    .inspectorRow .left{ flex-wrap: wrap; row-gap: 6px; }
.inspectorBar{ overflow-x: hidden; }
  
    /* Footer info can wrap (show full text without overflowing) */
/* Folder picker overlay uses help panel look */
    .folderPanel{ width: min(860px, calc(100vw - 24px)); }
    #folderOverlay .helpBody{ padding: 14px 16px 16px; font-size: 13px; }
    #folderOverlay .overlayList{
      margin: 0;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      background: rgba(255,255,255,0.04);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      word-break: break-word;
    }
    #folderOverlay .helpActions{
      display:flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 12px;
    }

  
    /* Header field alignment (labels above values) */
    .actions .field{
      display:flex;
      flex-direction: column;
      gap: 6px;
      align-items: stretch;
    }
    .actions .field .numWrap{ justify-content: space-between; }
    .actions .field input[type="number"]{ width: 96px; }

  
    /* Random 64 filter overlay */
    .filterPanel{ width: min(860px, calc(100vw - 24px)); }
    #filterOverlay input[type="text"]{
      width: 100%;
      height: calc(var(--ctrlH) - 10px);
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--text);
      border-radius: 10px;
      padding: 0 10px;
      outline:none;
      font-size: 11px;
      margin-top: 8px;
    }

  
    /* Header grouping + compact layout */
    .actionsRow1{
      display:flex;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items: flex-end;
    }
    .group{
      display:flex;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items: flex-end;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.04);
    }
    .tempoGroup{
      min-width: 420px;
    }
    .tempoGroup .tog{
      margin-right: 6px;
    }

  
    /* Header: 2 rows with grouped blocks */
    .actionsRow1{
      display:flex;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items: flex-end;
      justify-content: space-between;
    }
    .actionsRow2{
      display:flex;
      flex-wrap: wrap;
      gap: 10px 12px;
      align-items: center;
      justify-content: space-between;
      margin-top: 10px;
    }
    .actionsRow2 .group{
      padding: 7px 9px;
    }
    .headerGroup{
      flex: 1 1 520px;
      justify-content: flex-start;
    }
    .tempoGroup{
      flex: 1 1 420px;
      justify-content: flex-start;
    }

  
    /* Inspector info box: keep text inside and give it more width */
    .ctrl{ overflow: hidden; }
    .infoCtrl{ grid-column: span 2; }
    @media (max-width: 980px){
      .infoCtrl{ grid-column: span 3; }
    }
    @media (max-width: 720px){
      .infoCtrl{ grid-column: 1 / -1; }
    }

  
    /* Header: single row across full width */
    .actionsRow1{
      display:flex;
      flex-wrap: nowrap;
      gap: 10px 12px;
      align-items: flex-end;
      justify-content: space-between;
      width: 100%;
    }
    .actionsRow1 > .group{ flex: 0 0 auto; }
    .actionsRow1 .rowLeft.group,
    .actionsRow1 .rowRight.group{
      padding: 10px 12px;
    }
    @media (max-width: 1220px){
      .actionsRow1{ flex-wrap: wrap; }
    }

  
    /* Prevent long info strings from forcing grid overflow */
    .inspBody{ overflow: hidden; }
    .inspBody > .ctrl{ min-width: 0; }
    .ctrl{ min-width: 0; overflow: hidden; }
    .ctrl .lbl{ min-width: 0; }
    .ctrl .sub{ min-width: 0; width: 100%; overflow-wrap:anywhere; word-break:break-word; }
/* Header controls: keep items compact */
    .actions > *{ flex: 0 0 auto; }
    .actions button{ white-space: nowrap; }
    .actions .tog{ white-space: nowrap; }
    .actions .field{ min-width: 96px; }

  
    /* Compact header so all controls fit */
    header{ padding: 10px 14px 10px; }
    .actions{ gap: 8px 10px; }
    button, .btn, .warn, .good, .secondary{
      padding: 0 10px;
      font-size: 11px;
      height: calc(var(--ctrlH) - 8px);
    }
    .tog{
      height: calc(var(--ctrlH) - 8px);
      padding: 0 10px;
      font-size: 11px;
    }
    .tog .cap{ font-size: 11px; }
    .field label{ font-size: 10px; }
    .field input{
      height: calc(var(--ctrlH) - 8px);
      font-size: 11px;
      padding: 0 8px;
    }
    .actions .field input[type="number"]{ width: 82px; }
    .actions .field{ min-width: 84px; }
    .pill{ font-size: 11px; padding: 2px 8px; }

  
    .actions{ max-width: 100%; }
    .actionsWrap{ overflow-x: auto; overflow-y: visible; padding-bottom: 8px; -webkit-overflow-scrolling: touch; }

  
    /* Title + spec line on one row */
    .titleRow{
      display:flex;
      flex-wrap: wrap;
      align-items: baseline;
      gap: 10px 12px;
    }
    .specInline{
      display:flex;
      flex-wrap: wrap;
      gap: 6px 8px;
      font-size: 11px;
      color: var(--muted);
      opacity: 0.95;
      line-height: 1.2;
    }
    .specInline .spec{
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.04);
      white-space: nowrap;
    }


/* v2.28.43: M/R pills normal weight */
.cellTop .icons .icon{ font-weight: 400 !important; }



/* v2.28.48: keep all 6 inspector control blocks on one row (when screen allows) */
.inspBody{
  grid-template-columns: repeat(6, minmax(0, 1fr)) !important;
}
.inspBody .ctrl{ min-width: 0 !important; }

/* Info: wrap netjes binnen het control-block */
.infoCtrl .sub{
  white-space: pre-line;
  overflow: visible;
  text-overflow: clip;
  overflow-wrap: anywhere;
  word-break: break-word;
  line-height: 1.25;
}
/* v2.28.49: Info control should be same width as other inspector controls */
.infoCtrl{ grid-column: auto !important; }

/* v2.28.52: Info block mag niet clippen */
.ctrl.infoCtrl{ overflow: visible; }


/* v2.28.57: visual separators between header control groups */
.actions .sep{
  width: 1px;
  height: 32px;                 /* match button height */
  align-self: flex-end;         /* align to bottom of row */
  background: rgba(255,255,255,.18);
  margin: 0 10px 2px;           /* tiny drop to sit with buttons */
  border-radius: 1px;
  flex: 0 0 auto;
}


/* v2.28.59: prevent header horizontal overflow (Name field) */
.actions .field{ min-width: 0; }
.actions .field input[type="text"]{ min-width: 0; box-sizing: border-box; }

/* Make the Name control reliably fit in the viewport */
.actions .field[title^="Filename template"]{
  flex: 0 1 auto;
  max-width: 100%;
}
#nameTemplate{
  width: clamp(120px, 14vw, 219px);  /* never forces horizontal scroll */
  max-width: 100%;
}

/* v2.5.4: merged Name input + history dropdown button (no typeahead) */
.field.nameTpl{ position: relative; }
.field.nameTpl .tplWrap{ display:flex; align-items:stretch; gap:0; margin-top: 6px; }
.field.nameTpl .tplWrap > *{ height: calc(var(--ctrlH) - 8px); }
.field.nameTpl #nameTemplate{
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.field.nameTpl .tplDropBtn{
  display:flex; align-items:center; justify-content:center;
  height: calc(var(--ctrlH) - 8px);
  border: 1px solid rgba(255,255,255,.10);
  border-left: none;
  padding: 0 10px;
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
  border-top-right-radius: 9px;
  border-bottom-right-radius: 9px;
  background: rgba(255,255,255,.06);
  color: var(--fg);
  cursor: pointer;
}
.field.nameTpl .tplDropBtn:hover{ background: rgba(255,255,255,.10); }
.field.nameTpl .tplDropBtn:active{ transform: translateY(1px); }

.field.nameTpl .tplDropMenu{
  position:fixed;
    width: min(520px, 92vw);
  max-height: 240px;
  overflow:auto;
  background: rgba(18,22,34,.98);
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 12px;
  box-shadow: 0 18px 45px rgba(0,0,0,.55);
  padding: 6px;
  display:none;
  z-index: 9999;
}
.field.nameTpl .tplDropMenu.open{ display:block; }
.field.nameTpl .tplItem{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 8px;
  padding: 8px 9px;
  border-radius: 10px;
  cursor:pointer;
  user-select:none;
  font-size: 11px;
  line-height: 1.2;
}
.field.nameTpl .tplItem:hover{ background: rgba(255,255,255,.08); }
.field.nameTpl .tplItem .tplTxt{
  overflow:hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.field.nameTpl .tplHint{ opacity:.65; font-size: 11px; }

@media (max-width: 900px){
  #nameTemplate{ width: clamp(110px, 36vw, 150px); }
}

#nameTemplateHistory{
  width: clamp(120px, 14vw, 219px);
  max-width: 100%;
  height: calc(var(--ctrlH) - 8px);
}
/* v2.3.1: editable column names */
.colName{ display:flex; flex-direction:column; gap:6px; min-width: 0; }
.colTitle{ font-size: 11px; opacity: .85; }
.colTitleInput{
  width: 100%;
  max-width: 220px;
  padding: 6px 8px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(0,0,0,0.18);
  color: rgba(240,248,255,0.92);
  outline: none;
}
.colTitleInput:focus{
  border-color: rgba(125,211,252,0.35);
  box-shadow: 0 0 0 3px rgba(125,211,252,0.12);
}


/* v2.4.0: export preset naming + column name input styled like cell buttons */
.colTitleInput{
  width: 100%;
  max-width: 240px;
  padding: 7px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(125,211,252,0.14);
  color: rgba(240,248,255,0.95);
  font-size: 13px;
  font-weight: 600;
  letter-spacing: .2px;
  outline: none;
}
.colTitleInput::placeholder{ color: rgba(240,248,255,0.55); }
.colTitleInput:hover{ border-color: rgba(125,211,252,0.32); }
.colTitleInput:focus{
  border-color: rgba(125,211,252,0.45);
  box-shadow: 0 0 0 3px rgba(125,211,252,0.16);
  background: rgba(125,211,252,0.18);
}


/* v2.5.5: allow header dropdowns to overlap main */
header{ overflow: visible; }
.actions{ overflow: visible; }



/* v2.5.24 Wave Editor overlay (foundation) */
.wavePanel{ width: min(980px, calc(100vw - 24px)); }
.waveEditorWrap{ display:flex; flex-direction:column; gap:12px; }
.waveBig{ width:100%; height:auto; border-radius:14px; border:1px solid rgba(255,255,255,0.12); background: rgba(0,0,0,0.25); }
.waveEditorMeta{ display:flex; gap:14px; flex-wrap:wrap; opacity:0.95; }
.waveEditorMeta .kv{ display:flex; gap:8px; align-items:baseline; }
.waveEditorMeta .k{ opacity:0.7; font-size:12px; }
.waveEditorMeta .v{ font-variant-numeric: tabular-nums; }
.waveEditorHint{ font-size:12px; opacity:0.7; }


/* v2.5.30 Wave Editor shortcuts */
.waveShortcuts{ margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.10); }
.waveShortcutsTitle{ font-size:12px; opacity:0.85; margin-bottom:6px; letter-spacing:0.2px; }
.waveShortcutsList{ margin:0; padding-left:18px; column-count:2; column-gap:26px; }
.waveShortcutsList li{font-size:12px; opacity:0.78; line-height:1.25;; break-inside:avoid; margin:0 0 6px 0; }
.waveShortcutsNote{ margin-top:8px; font-size:12px; opacity:0.65; }



/* v2.6.7 Wave Editor affordances */
.wave.waveLong {
  cursor: url("data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%20width%3D%2732%27%20height%3D%2732%27%20viewBox%3D%270%200%2032%2032%27%3E%0A%3Cpath%20d%3D%27M10.2%208.2a3.2%203.2%200%201%200%200%206.4a3.2%203.2%200%200%200%200-6.4Zm0%201.8a1.4%201.4%200%201%201%200%202.8a1.4%201.4%200%200%201%200-2.8Zm11.6%200a3.2%203.2%200%201%200%200%206.4a3.2%203.2%200%200%200%200-6.4Zm0%201.8a1.4%201.4%200%201%201%200%202.8a1.4%201.4%200%200%201%200-2.8Z%27%20fill%3D%27white%27%20fill-opacity%3D%270.95%27/%3E%0A%3Cpath%20d%3D%27M12.2%2014.2l7.6%207.6c.4.4.4%201%200%201.4s-1%20.4-1.4%200l-7.6-7.6l-2.6%202.6c-.4.4-1%20.4-1.4%200s-.4-1%200-1.4l4-4c.4-.4%201-.4%201.4%200Z%27%20fill%3D%27white%27%20fill-opacity%3D%270.95%27/%3E%0A%3Cpath%20d%3D%27M19.8%2014.2l-7.6%207.6c-.4.4-.4%201%200%201.4s1%20.4%201.4%200l7.6-7.6l2.6%202.6c.4.4%201%20.4%201.4%200s.4-1%200-1.4l-4-4c-.4-.4-1-.4-1.4%200Z%27%20fill%3D%27white%27%20fill-opacity%3D%270.95%27/%3E%0A%3C/svg%3E") 16 16, pointer;
}
.wave.waveShort {
  cursor: default;
}


/* v2.6.7 Scissors affordance (cross-browser) */
.wave.scissors{ cursor: crosshair; }
.waveBadge{
  position:absolute;
  top:6px;
  right:6px;
  font-size:15px;
  line-height:1;
  opacity:0.80;
  pointer-events:none;
  user-select:none;
  background: transparent;
  border: none;
  padding: 0;
  border-radius: 0;
  text-shadow: 0 1px 8px rgba(0,0,0,0.55);
}


/* v2.6.7 Wave Editor corner scissor */
.waveCanvasWrap{ position:relative; }
.waveScissorIcon{
  position:absolute;
  top:10px;
  right:10px;
  font-size:18px;
  line-height:1;
  opacity:0.75;
  pointer-events:none;
  user-select:none;
  text-shadow: 0 1px 8px rgba(0,0,0,0.55);
}


/* v2.6.7 Waveform wrapper for in-scope scissors */
.waveWrap{ position:relative; display:block; }
.waveWrap .waveBadge{
  position:absolute;
  top:6px;
  right:6px;
  font-size:15px;
  line-height:1;
  opacity:0.80;
  pointer-events:none;
  user-select:none;
  background: transparent;
  border: none;
  padding: 0;
  border-radius: 0;
  text-shadow: 0 1px 8px rgba(0,0,0,0.55);
  display:none;
}


/* v2.6.7 Random 64 filter indicator */
#random64Btn{ position:relative; }
#random64Btn .filterIcon{
  display:none;
  width:14px;
  height:14px;
  margin-left:6px;
  vertical-align:-2px;
  background-image: url("data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A//www.w3.org/2000/svg%27%20viewBox%3D%270%200%2024%2024%27%3E%0A%3Cpath%20d%3D%27M3%205h18l-7%208v5l-4%202v-7L3%205z%27%20fill%3D%27white%27%20fill-opacity%3D%270.9%27/%3E%0A%3C/svg%3E");
  background-repeat:no-repeat;
  background-size:14px 14px;
  opacity:0.85;
}
#random64Btn.hasFilter .filterIcon{ display:inline-block; }


/* --- Split Editor selections --- */
#splitBig{ touch-action:none; }

.toast.warn{
  background: rgba(190, 70, 15, 0.94);
  border-color: rgba(255,190,140,0.35);
}

  /* Split editor hint readability */
  #splitHint{font-size:13px; opacity:0.95; line-height:1.25;}

  /* Split hint: visible + wraps */
  #splitHint{
    display:block;
    white-space: normal !important;
    overflow: visible !important;
    max-width: 100% !important;
    padding: 8px 10px !important;
    margin-top: 10px !important;
    border-radius: 10px;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.10);
    line-height: 1.25 !important;
    font-size: 13px !important;
    opacity: 0.98 !important;
  }


  /* Split hint wrap */
  #splitHint{white-space:normal !important; max-width:100% !important; line-height:1.25;}


  /* === Handle Magnifier (Fase 1) === */
  .tcmMag{
    position: fixed;
    z-index: 99999;
    pointer-events: none;
    transform: translate(-50%, -115%);
    background: rgba(18,18,20,0.96);
    border: 1px solid rgba(255,255,255,0.18);
    border-radius: 14px;
    padding: 8px 10px 10px;
    box-shadow: 0 10px 35px rgba(0,0,0,0.45);
  }
  .tcmMag canvas{
    display:block;
    border-radius: 12px;
    background: rgba(0,0,0,0.35);
  }
  .tcmMagLbl{
    margin-top: 6px;
    font-size: 11px;
    opacity: 0.9;
    white-space: nowrap;
    display: flex;
    align-items: center;
    gap: 8px;
  }

    /* Z Auto-Norm indicator */
  .z-indicator{
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 18px;
    height: 18px;
    font-size: 11px;
    font-weight: 700;
    line-height: 1;
    margin-left: 8px;
    vertical-align: middle;
    user-select: none;
  }
  .z-indicator::before{
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 3px;
    border: 1px solid rgba(255,255,255,0.55);
    background: rgba(255,255,255,0.08);
    opacity: 0.25;
  }
  .z-indicator.armed::before{
    opacity: 0.55;
  }
  .z-indicator.active::before{
    opacity: 1;
    box-shadow: 0 0 0 2px rgba(255,255,255,0.15);
  }
  /* Right align Z indicator in magnifier label */
  #tcmMagLbl .z-indicator{
    margin-left: auto;
  }


#tcmMag{
  border-radius: 10px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.35);
  backdrop-filter: blur(2px);
  transition: opacity 120ms ease, transform 120ms ease;
  transform: translate(-50%, -105%);
  opacity: 0;
}
#tcmMag.tcmMagOn{ opacity: 1; transform: translate(-50%, -115%); }

/* Help compactness tweaks (2.7.16) */
.helpCardRelease .helpList{ column-gap: 18px; }
.helpCardRelease .helpList li{ margin: 2px 0; }
.helpCardRelease{ padding-bottom: 10px; }
.helpTip{ margin-top: 8px; }

/* Help popup compact fit tweaks (avoid internal scrollbar on common viewports) */
.helpPanel{max-height:92vh;}
.helpBody{padding:10px 12px;}
.helpGrid{gap:10px;}
.helpCard{padding:10px 12px;}
.helpCard h3{margin:0 0 6px;font-size:13px;}
.helpList{margin:6px 0 0;line-height:1.25;}
.helpList li{margin:0 0 6px;}
.helpCardRelease .helpList{column-gap:16px;}
.helpTip{margin-top:10px;}

/* --- Help compact + no horizontal overflow --- */
.helpOverlay, .helpPanel { overflow-x: hidden !important; }
.helpGrid { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; }
.helpCard { min-width: 0 !important; }
.helpCard *, .helpPanel * { word-break: break-word; overflow-wrap: anywhere; }
/* Release notes: two columns, compact */
.helpCard.releaseNotes ul { columns: 2; column-gap: 16px; }
.helpCard.releaseNotes li { break-inside: avoid; margin: 0 0 6px 0; }

</style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="topline">
        <div>
          <div class="titleRow">
            <h1 id="appTitle">Tempera Cell Matrix</h1><span class="spec" id="aboutBadge" title="">v</span>
            <div class="specInline" id="specLine"></div>
          </div>
          <div class="sub">
            Click a cell to select it. <span class="kbd">Double‑click</span> or <span class="kbd">▶</span> to play.
            Stop: <span class="kbd">Esc</span>.
            Drag cell→cell: swap (Alt = copy).
          </div>
        </div>

        <div class="actionsWrap"><div class="actions">
          <div class="btnGroupInline"><button class="pop" id="random64Btn" title="Select a folder (including subfolders). In the picker, files may appear grey—choose the folder and confirm.">Random 64 <span class="filterIcon" aria-hidden="true"></span></button>
          <button class="warn" id="exportAllBtn">Export all (ZIP)</button>
          <button class="secondary" id="importPresetBtn" title="Load preset JSON exported by this app, then relink samples from a folder">Import Preset</button>
          <button class="secondary" id="helpBtn" title="Show help / shortcuts">Help</button></div>

          <span class="sep" aria-hidden="true"></span>

          <label class="tog" title="Tempo mode uses BPM + beats-per-cell to set cell/column lengths. Off = fixed 2^20 points per column.">
            <input type="checkbox" id="tempoMode">
            Tempo (BPM)
          </label>

          <div class="field" title="Beats per minute">
            <label for="bpm">BPM</label>
            <div class="numCtl">
              <button class="tiny secondary stepBtn" data-for="bpm" data-dir="-1" aria-label="BPM minus">−</button>
              <input id="bpm" type="number" min="20" max="400" step="1" value="120">
              <button class="tiny secondary stepBtn" data-for="bpm" data-dir="1" aria-label="BPM plus">+</button>
            </div>
          </div>

          <div class="field" title="How many beats in one cell (slice).">
            <label for="beatsPerCell">Beats/cell</label>
            <div class="numCtl">
              <button class="tiny secondary stepBtn" data-for="beatsPerCell" data-dir="-1" aria-label="Beats per cell minus">−</button>
              <input id="beatsPerCell" type="number" min="0.125" max="16" step="0.125" value="1">
              <button class="tiny secondary stepBtn" data-for="beatsPerCell" data-dir="1" aria-label="Beats per cell plus">+</button>
            </div>
          </div>

          <span class="sep" aria-hidden="true"></span>

          <label class="tog" title="For Load+Slice: time-fit (pitch changes) so the full sample exactly fills the column.">
            <input type="checkbox" id="splitFit">
            Split fit (pitch)
          </label>

          <label class="tog" title="Normalize on load (per cell) by setting gain based on peak level.">
            <input type="checkbox" id="normalizeOnLoad">
            Normalize load
          </label>

          <span class="sep" aria-hidden="true"></span>

          <div class="field nameTpl" title="Filename template. Placeholders: {col} {colname} {mode} {bpm} {sr} {frames} {date}">
            <label for="nameTemplate">Name</label>
            <div class="tplWrap">
              <input id="nameTemplate" type="text" value="tempera_{mode}_{bpm}bpm_col{col}_{colname}_{date}">              <button class="tplDropBtn" id="nameTemplateDropBtn" type="button" title="Recent templates">▾</button>
            </div>
            <div class="tplDropMenu" id="nameTemplateDropMenu" role="listbox" aria-label="Recent templates"></div>
          </div>

          
          
          
          
          
        </div>
      </div>
    </div>
  <div class="copyrightTop"><span id="copyrightText"></span><div class="miniRow"><button class="good audioMini" id="enableAudioBtn" title="Required on some browsers before audio playback">Enable audio</button><button class="secondary audioMini" id="stopBtn">Stop</button><button class="danger audioMini" id="clearAllBtn">Clear all</button></div></div>
</header>

  <main>
    <div class="layout">
      <div class="cols" id="cols"></div>

      <div class="inspector" id="inspector">
        <div class="inspHead">
          <div class="inspTitle">
            <div class="t" id="inspTitle">Cell settings</div>
            <div class="d" id="inspDesc">Select a cell.</div>
          </div>
          <div class="ctrlRow">
            <button class="tiny secondary" id="inspClearBtn">Clear</button>
            <button class="tiny secondary" id="inspPlayBtn">▶ Play</button>
            <button class="tiny secondary" id="inspLoadBtn">Load</button>
            <button class="tiny good" id="inspNormalizeBtn">Normalize</button>
            <button class="tiny secondary" id="inspCopyToColBtn" title="Copy settings to all 8 cells in this column">Copy→Col</button>
            <button class="tiny secondary" id="inspCopyToAllBtn" title="Copy settings to all 64 cells">Copy→All</button>
          </div>
        </div>

        <div class="inspBody">

          <div class="ctrl">
            <div class="lbl"><span>Cell name</span><b>&nbsp;</b></div>
            <input id="cellName" class="colTitleInput" placeholder="C1" style="max-width:100%;" />
          </div>


          <div class="ctrl">
            <div class="lbl"><span>Volume</span><b id="volVal">1.00×</b></div>
            <input id="vol" type="range" min="0" max="2" step="0.01" value="1">
          </div>

          <div class="ctrl">
            <div class="lbl"><span>Fade In (ms)</span><b id="fadeInVal">0</b></div>
            <input id="fadeIn" type="range" min="0" max="1500" step="5" value="0">
          </div>

          <div class="ctrl">
            <div class="lbl"><span>Fade Out (ms)</span><b id="fadeOutVal">0</b></div>
            <input id="fadeOut" type="range" min="0" max="1500" step="5" value="0">
          </div>

          <div class="ctrl">
            <div class="lbl"><span>Fit mode</span><b id="fitVal">rate</b></div>
            <select id="fitMode">
              <option value="rate">fit (rate/pitch)</option>
              <option value="padtrim">pad/trim</option>
</select>
          </div>

          <div class="ctrl">
            <div class="lbl"><span>Switches</span><b>&nbsp;</b></div>
            <div class="ctrlRow" style="gap:14px;">
              <label class="chk"><input id="mute" type="checkbox"> Mute</label>
              <label class="chk"><input id="reverse" type="checkbox"> Reverse</label>
</div>
          </div>
        </div>
      </div>
    </div>
  </main>

  
  
  <!-- Random 64 Filter Overlay -->
  <div class="overlay" id="filterOverlay" aria-hidden="true">
    <div class="helpPanel filterPanel" role="dialog" aria-modal="true" aria-label="Random 64 filters">
      <div class="helpHead">
        <div class="helpTitle">Random 64 filters</div>
        <button class="helpClose" id="filterOverlayClose" title="Close">✕</button>
      </div>
      <div class="helpBody" style="font-size:13px;">
        <p class="muted" style="margin-top:0;">
          Use comma separated tokens. Matching is case-insensitive and checks the filename.
        </p>

        <div class="helpGrid" style="margin-top:10px;">
          <div class="helpCard">
            <div class="helpCardTitle">Include</div>
            <p class="muted">Only load files that contain <b>any</b> token below. Leave blank = include everything.</p>
            <input id="filterIncludeInput" type="text" placeholder="e.g. kick,snare,hat" />
          </div>

          <div class="helpCard">
            <div class="helpCardTitle">Exclude</div>
            <p class="muted">Skip files that contain <b>any</b> token below. Leave blank = exclude nothing.</p>
            <input id="filterExcludeInput" type="text" placeholder="e.g. fx,loop" />
          </div>
        </div>

        <div class="helpCard" style="margin-top:10px;">
          <div class="helpCardTitle">Tip</div>
          <p class="muted" style="margin:0;">
            Example: include <span class="kbd">kick,snare,hat</span> and exclude <span class="kbd">fx,loop</span>.
          </p>
        </div>

        <div class="overlayActions helpActions" style="margin-top:12px;">
          <button class="secondary" id="filterOverlayClearBtn" title="Clear both include and exclude filters">Clear</button>
          <button class="secondary" id="filterOverlayCancelBtn">Cancel</button>
          <button class="good" id="filterOverlaySaveBtn">Save</button>
        </div>
      </div>
    </div>
  </div>
  <!-- /Random 64 Filter Overlay -->

<!-- Folder Picker Overlay (Preset Import) -->
  <div class="overlay" id="folderOverlay" aria-hidden="true">
    <div class="helpPanel folderPanel" role="dialog" aria-modal="true" aria-label="Select sample folder">
      <div class="helpHead">
        <div class="helpTitle">Select sample folder</div>
        <button class="helpClose" id="folderOverlayClose" title="Close">✕</button>
      </div>
      <div class="helpBody">
        <p class="muted" id="folderOverlayHint">
          Pick the top-level folder that contains your original samples (subfolders are included).
        </p>
        <div class="helpCard" style="margin-top:10px;"><div class="overlayList" id="folderOverlayList"></div></div>
        <div class="overlayActions helpActions">
          <button class="good" id="folderOverlayPickBtn">Choose folder…</button>
          <button class="secondary" id="folderOverlayCancelBtn">Cancel</button>
        </div>
        <p class="muted" style="margin-top:10px;">
          Tip: choose the folder that contains the files listed above. Keeping the same filenames (and ideally the same folder structure) makes relinking reliable.
        </p>
      </div>
    </div>
  </div>
  <!-- /Folder Picker Overlay -->


<!-- Preset Name Overlay (Export All ZIP) -->
<div class="overlay" id="presetNameOverlay" aria-hidden="true">
  <div class="helpPanel folderPanel" role="dialog" aria-modal="true" aria-label="Preset name">
    <div class="helpHead">
      <div class="helpTitle">Export preset</div>
      <button class="helpClose" id="presetNameOverlayClose" title="Close">✕</button>
    </div>
    <div class="helpBody">
      <p class="muted">Preset name is used for the ZIP filename and the preset JSON filename. The preset JSON is named so it sorts after all samples when extracted.</p>
      <div class="helpCard" style="margin-top:10px;">
        <label class="muted" for="presetNameInput" style="display:block;margin-bottom:6px;">Preset name</label>
        <input id="presetNameInput" class="colNameInput" type="text" autocomplete="off" spellcheck="false" />
      </div>
      <div class="overlayActions helpActions" style="margin-top:12px;">
        <button class="good" id="presetNameOkBtn">OK</button>
        <button class="secondary" id="presetNameCancelBtn">Cancel</button>
      </div>
    </div>
  </div>
</div>
<!-- /Preset Name Overlay -->


<div class="toast" id="toast"></div>

  <!-- One hidden input for all loads -->
  <input id="fileInput" type="file" accept=".wav,audio/wav,audio/x-wav,audio/wave,audio/vnd.wave,audio/*" hidden />
  <input id="folderInput" type="file" accept=".wav,audio/wav,audio/x-wav,audio/wave,audio/vnd.wave,audio/*" webkitdirectory multiple hidden />


  <!-- Help Overlay -->
  <div class="overlay" id="helpOverlay" aria-hidden="true">
    <div class="helpPanel" role="dialog" aria-modal="true" aria-label="Help">
      <div class="helpHead">
        <div class="helpTitle">Tempera Cell Matrix — Help</div>
        <button class="helpClose" id="helpCloseBtn" title="Close">✕</button>
      </div>

      <div class="helpBody">
<div class="helpGrid">

          <div class="helpCard">
            <h3>Wave Editor</h3>
            <p>Click the <b>waveform</b> in a cell to open the full source waveform and choose the exact slice for that cell.</p>
            <ul class="helpList">
              <li><b>Click</b> the mini-wave in a cell to open the full source waveform.</li>
              <li><b>Drag</b> inside selection to move. Drag edges to resize.</li>
              <li><b>L / M / R</b> — choose Left edge / Move / Right edge control (also affects arrow nudges).</li>
              <li><b>Zoom window</b>: appears on dense waves (or when resizing). <b>+</b>/<b>-</b> zooms, <b>Z</b> toggles Auto‑Norm.</li>
              <li><b>Esc</b>: if zoom window is visible → hide zoom. Otherwise → close editor.</li>
              <li><b>← / →</b> nudge selection • <b>Shift</b>=coarse • <b>Alt/Option</b>=fine.</li>
              <li><b>Trim</b> trims source to selection (Undo available). <b>Apply</b> commits selection to the cell (used for playback + export).</li>
</ul>
          </div>

          <div class="helpCard">
            <h3>Basics</h3>
            <p>8 columns × 8 rows. Columns are <b>Samples</b>. Rows are <b>Cells</b> (1..8).</p>
            <ul class="helpList">
              <li>Click a cell to select it (settings panel).</li>
              <li><b>Double‑click</b> a cell or press <b>▶</b> to play.</li>
              <li><b>Esc</b> stops playback. In editors: Esc hides the zoom window first, then closes the editor.</li>
              <li><b>Tempo mode</b> uses BPM + Beats/cell and distributes rounding across 8 slices (no drift).</li>
              <li>Drag cell→cell: swap. <b>Alt</b> + drag: copy.</li>
            
              <li><b>Shift + click Random 64</b> to open the filter dialog:
                <ul>
                  <li><b>Include</b>: only filenames containing any token (comma separated)</li>
                  <li><b>Exclude</b>: skip filenames containing any token (comma separated)</li>
                </ul>
                Example: include <span class="kbd">kick,snare,hat</span> and exclude <span class="kbd">fx,loop</span>.
              </li>
</ul>
</div>

          <div class="helpCard">
            <h3>Loading audio</h3>
            <ul class="helpList">
              <li><b>Cell Load</b>: click <b>Load</b> inside a cell or drop a file onto that cell.</li>
              <li><b>Load+Slice</b>: pick one file → opens Slice Editor where you can drag/resize 8 blocks, then <b>Apply</b> to the column.</li>
              <li><b>Load 8</b>: select 8 files → fills the 8 cells top→bottom.</li>
              <li><b>Random 64</b>: pick a folder (subfolders included) → fills all cells randomly.</li>
            </ul>
</div>

          <div class="helpCard">
            <h3>Editing</h3>
            <ul class="helpList">
              <li>Use the <b>Cell settings</b> panel to change Gain, Mute, Reverse, Fade In/Out and Fit mode.</li>
              <li>Fades are drawn as an <b>envelope overlay</b> on top of the oscilloscope.</li>
              <li>Gain is shown as a small bar under the oscilloscope (no text).</li>
            </ul>
          </div>

          <div class="helpCard">
            <h3>Import / Export</h3>
              <p><b>Import Preset</b>: load the preset JSON exported by this app (e.g. <span class="kbd">zz_TCM-Preset_MyPreset_20260111.json</span>), then choose your top-level sample folder. Subfolders are included. The folder overlay shows example filenames to help you pick the right folder.</p>
            <ul class="helpList">
              <li><b>Export</b> in a column: exports that column to WAV.</li>
              <li><b>Export 8</b> in a column: exports the 8 cells as separate WAV files (downloaded as one ZIP). Filenames use Sample + C#.</li>
              <li><b>Export all (ZIP)</b>: exports up to 8 columns and downloads one ZIP file.</li>
              <li>Empty columns are skipped.</li>
            </ul>
          </div>

          <div class="helpCard helpCardRelease">
            <h3>Release notes</h3>
            <ul class="helpList" id="releaseNotes"></ul>
          </div>

</div>

          <div class="helpTip">
            Tip: If you don’t hear previews, click <b>Enable audio</b> (browser requirement).
          </div>
        </div>
      </div>
    </div>
  </div>

<script>

// Split Editor constraints
const MAX_SPLIT_LOAD_SEC = 300; // seconds
(() => {
  "use strict";

  // ====== On-page error reporter (persistent + copyable) ======
  function _tcmFormatAny(x){
    try{
      if (x == null) return String(x);
      if (typeof x === "string") return x;
      if (x && (x.stack || x.message)) return String(x.stack || x.message);
      return JSON.stringify(x, null, 2);
    }catch(_){
      return String(x);
    }
  }

  function showFatal(err){
    try{
      const msg = _tcmFormatAny(err);
      const text = "Tempera Cell Matrix error:\n\n" + msg;
      window.__TCM_LAST_FATAL__ = text;

      let overlay = document.getElementById("tcmFatalOverlay");
      if (!overlay){
        overlay = document.createElement("div");
        overlay.id = "tcmFatalOverlay";
        overlay.className = "overlay show";
        overlay.style.zIndex = "35000";

        const panel = document.createElement("div");
        panel.className = "helpPanel";
        panel.style.width = "min(980px, calc(100vw - 24px))";

        const head = document.createElement("div");
        head.className = "helpHead";

        const title = document.createElement("div");
        title.className = "helpTitle";
        title.textContent = "Tempera Cell Matrix error";

        const btns = document.createElement("div");
        btns.style.display = "flex";
        btns.style.gap = "8px";
        btns.style.alignItems = "center";

        const copyBtn = document.createElement("button");
        copyBtn.className = "helpClose";
        copyBtn.type = "button";
        copyBtn.textContent = "Copy";

        const closeBtn = document.createElement("button");
        closeBtn.className = "helpClose";
        closeBtn.type = "button";
        closeBtn.textContent = "✕";

        btns.appendChild(copyBtn);
        btns.appendChild(closeBtn);

        head.appendChild(title);
        head.appendChild(btns);

        const body = document.createElement("div");
        body.className = "helpBody";

        const pre = document.createElement("pre");
        pre.id = "tcmFatalText";
        pre.style.margin = "0";
        pre.style.padding = "12px";
        pre.style.borderRadius = "12px";
        pre.style.border = "1px solid rgba(255,255,255,0.10)";
        pre.style.background = "rgba(0,0,0,0.28)";
        pre.style.whiteSpace = "pre-wrap";
        pre.style.wordBreak = "break-word";
        pre.style.userSelect = "text";
        pre.style.cursor = "text";
        pre.tabIndex = 0;

        body.appendChild(pre);
        panel.appendChild(head);
        panel.appendChild(body);
        overlay.appendChild(panel);
        document.body.appendChild(overlay);

        const hide = () => {
          overlay.classList.remove("show");
          overlay.style.display = "none";
        };

        overlay.addEventListener("click", (e) => { if (e.target === overlay) hide(); });
        closeBtn.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); hide(); });

        copyBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          const t = document.getElementById("tcmFatalText")?.textContent || "";
          try{
            await navigator.clipboard.writeText(t);
            toast("Copied error to clipboard", 1800);
          }catch(_){
            try{
              const r = document.createRange();
              const node = document.getElementById("tcmFatalText");
              r.selectNodeContents(node);
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(r);
              document.execCommand("copy");
              sel.removeAllRanges();
              toast("Copied error to clipboard", 1800);
            }catch(__){
              toast("Copy failed (browser restriction)", 2600);
            }
          }
        });

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && overlay.classList.contains("show")) hide();
        });
      }

      overlay.style.display = "flex";
      overlay.classList.add("show");
      const pre = document.getElementById("tcmFatalText");
      if (pre) pre.textContent = text;
      overlay.style.zIndex = "35000";
    }catch(_){}
  }

  window.addEventListener("error", (e) => {
    const payload = (e && e.error) ? e.error : (e && e.message ? e.message : e);
    showFatal(payload);
  });

  window.addEventListener("unhandledrejection", (e) => {
    const payload = (e && (e.reason != null)) ? e.reason : e;
    showFatal(payload);
  });



  // Single source of truth for version text
  const APP_VERSION = '2.7.27-beta';

  const APP_BUILD_DATE = "2026-01-13";
  const CHANGELOG = [
  "2.7.16 — Matrix cell labels: filename truncates with … so C1–C8 stays visible.",
  "2.7.15 — Imported slices: mini-wave shows selection overlay + scissors correctly.",
  "2.7.14 — Mini-wave click always opens Wave Editor (also for sliced/imported cells).",
  "2.7.13 — Matrix labels use C1–C8 (no more ‘Cell 1…’).",
  "2.7.12 — Fast naming: Enter focuses Cell name; Tab jumps across Sample names.",
  "2.7.11 — Wave Editor prefers original full source for sliced cells.",
  "2.7.10 — Presets now store original slice windows (start/length) from Load+Slice.",
  "2.7.9 — Preset import restores Load+Slice edits (custom slice windows, not full samples).",
  "2.7.8 — UI: Footer cards compact + equal height; controls centered.",
  "2.7.7 — Export 8 uses Column/Cell names for filenames.",
  "2.7.6 — Names: editable Column/Cell names + presets save/load them.",
  "2.7.4 — Zoom window: smaller size used in Slice Editor + Wave Editor.",
  "2.7.0 — Load+Slice: new Slice Editor + Wave Editor with zoom, Z auto-norm, L/M/R + nudging."
];


  function renderReleaseNotes(){
    const ul = document.getElementById("releaseNotes");
    if (!ul) return;
    ul.innerHTML = "";
    for (const line of (Array.isArray(CHANGELOG) ? CHANGELOG : [])){
      const li = document.createElement("li");
      li.textContent = line;
      ul.appendChild(li);
    }
  }

  // Waveform peak caching (performance)
  const MINI_PEAKS_POINTS = 96; // fixed resolution for cell mini-waveforms


// ====== Preset path helpers (for easier relinking) ======
function computeSampleRootHintFromState(){
  // Compute a stable "root hint" from all relPaths in current state.
  // This is NOT a filesystem path; it's the common folder prefix inside the sample set.
  const paths = [];
  for (let c=0;c<COLS;c++){
    for (let r=0;r<ROWS;r++){
      const rel = state.cells[c][r]?.origin?.relPath;
      if (rel && typeof rel === "string") paths.push(rel);
    }
  }
  return computeCommonFolderPrefix(paths);
}

function computeTopFoldersFromState(){
  const tops = new Set();
  for (let c=0;c<COLS;c++){
    for (let r=0;r<ROWS;r++){
      const rel = state.cells[c][r]?.origin?.relPath;
      if (!rel || typeof rel !== "string") continue;
      const seg = rel.split(/[\/]/).filter(Boolean)[0];
      if (seg) tops.add(seg);
    }
  }
  return Array.from(tops).slice(0, 24);
}

function computeCommonFolderPrefix(paths){
  const cleaned = (paths || [])
    .map(p => String(p).replace(/\\/g, "/").replace(/^\/+/, "").trim())
    .filter(Boolean);

  if (!cleaned.length) return "";

  // Only use folder portion (drop filename if present)
  const folders = cleaned.map(p => {
    const idx = p.lastIndexOf("/");
    return idx >= 0 ? p.slice(0, idx+1) : "";
  }).filter(Boolean);

  if (!folders.length) return "";

  let prefix = folders[0];
  for (let i=1;i<folders.length;i++){
    const b = folders[i];
    const max = Math.min(prefix.length, b.length);
    let j=0;
    while (j<max && prefix[j] === b[j]) j++;
    prefix = prefix.slice(0, j);
    if (!prefix) break;
  }
  // Cut to last complete folder boundary
  const lastSlash = prefix.lastIndexOf("/");
  if (lastSlash >= 0) prefix = prefix.slice(0, lastSlash+1);
  // Prefer just the first folder if prefix is too deep/empty
  if (!prefix){
    const seg = folders[0].split("/").filter(Boolean)[0];
    return seg ? (seg + "/") : "";
  }
  return prefix;
}

function computeRootHintFromPreset(preset){
  // Prefer explicit hint if present, else derive from relPaths inside preset
  const explicit = (preset && typeof preset.sampleRootHint === "string") ? preset.sampleRootHint : "";
  if (explicit) return explicit;

  const paths = [];
  try{
    const cols = preset?.columns;
    if (Array.isArray(cols)){
      for (const col of cols){
        const cells = col?.cells;
        if (!Array.isArray(cells)) continue;
        for (const cell of cells){
          const rel = (cell?.relPath || cell?.origin?.relPath || "").toString();
          if (rel) paths.push(rel);
        }
      }
    }
  }catch{}
  return computeCommonFolderPrefix(paths);
}

  // ====== Constants ======
  const COLS = 8;
  const ROWS = 8;
  const SR = 48000;
  const CH = 2;

  // Perf step 2b: cache DOM refs for cells (avoid repeated getElementById/querySelector in hot paths)
  const __cellDom = Array.from({length: COLS}, () => Array.from({length: ROWS}, () => null));


  // Fixed mode: exactly 2^20 interleaved sample points per column
  const TOTAL_SAMPLE_POINTS = 1048576;        // interleaved stereo
  const FIXED_COL_FRAMES = TOTAL_SAMPLE_POINTS / CH; // 524288
  const FIXED_CELL_FRAMES = FIXED_COL_FRAMES / ROWS; // 65536

  // ====== State ======
  const state = {
    audioCtx: null,
    currentSrc: null,
    currentCellEl: null,

    // per cell: src48k left/right arrays (variable length), filename, settings, peaks
    cells: Array.from({length: COLS}, () => Array.from({length: ROWS}, () => makeEmptyCell())),
    colNames: Array.from({length: COLS}, (_, i) => `Sample ${i+1}`),
    cellNames: Array.from({length: COLS}, (_, c) => Array.from({length: ROWS}, (_, r) => `C${r+1}`)),


    selected: { col: 0, row: 0, has: false },

    // pending picker action
    pick: { kind: null, col: null, row: null }, // kind: 'cell'|'split'|'colmulti'
  };

  // Display names (Column/Cell) used across editors and UI
  function getColDisplayName(c){
    const v = (state.colNames && state.colNames[c] != null) ? String(state.colNames[c]).trim() : "";
    return v ? v : `Sample ${c+1}`;
  }
  function getCellDisplayName(c, r){
    const v = (state.cellNames && state.cellNames[c] && state.cellNames[c][r] != null) ? String(state.cellNames[c][r]).trim() : "";
    return v ? v : `C${r+1}`;
  }


  // ====== Full-source store for Wave Editor (foundation) ======
  const sourceStore = new Map(); // key -> {L,R,name,peaks}
  function getSourceKeyFromFile(file, fallbackName=""){
    const n0 = (file && file.name) ? file.name : (fallbackName || "");
    const n = (n0 && String(n0).trim()) ? String(n0).trim() : "sample";
    const s = (file && typeof file.size === "number") ? file.size : 0;
    const lm = (file && typeof file.lastModified === "number") ? file.lastModified : 0;
    const rp = (file && (file.webkitRelativePath || file._relPath)) ? (file.webkitRelativePath || file._relPath) : "";
    let key = [rp, n, s, lm].join("::");
    if (!key || key === "::sample::0::0" || key === "::::"){
      key = ["file", n, Date.now(), Math.random().toString(16).slice(2)].join("::");
    }
    return key;
  }
  function ensureSourceInStore(key, left, right, name){
    if (!key) return;
    if (sourceStore.has(key)) return;
    const peaks = computePeaks(left, right, 900);
    sourceStore.set(key, {L:left, R:right, name: name || "sample", peaks, peaksByW: new Map([[900,peaks]])});
  }

  function makeEmptyCell(){
    return {
      name: "",
      left: null,   // Float32Array @ 48kHz
      right: null,  // Float32Array @ 48kHz
      peaks: null,  // Float32Array
      settings: {
        gain: 1.0,
        mute: false,
        reverse: false,
        fadeInMs: 0,
        fadeOutMs: 0,
        fitMode: "padtrim", // rate|padtrim|loop
      },
      cache: { key: "", L: null, R: null, frames: 0 }
    };
  }

  
  // ====== Random 64 filename filters (optional) ======
  const FILTER_KEY_INCLUDE = "tcm_filter_include";
  const FILTER_KEY_EXCLUDE = "tcm_filter_exclude";

  function updateRandom64FilterIndicator(){
    try{
      const btn = document.getElementById("random64Btn");
      if (!btn) return;
      const inc = (localStorage.getItem(FILTER_KEY_INCLUDE) || "").trim();
      const exc = (localStorage.getItem(FILTER_KEY_EXCLUDE) || "").trim();
      const has = !!(inc || exc);
      btn.classList.toggle("hasFilter", has);
      btn.title = has
        ? "Pick a folder (recursive). Filter is active (Shift opens filters)."
        : "Pick a folder (recursive). Shift opens filters.";
    }catch(_){}
  }

  function getFilterList(key){
    try{
      const raw = (localStorage.getItem(key) || "").trim();
      if (!raw) return [];
      return raw.split(",").map(s => s.trim().toLowerCase()).filter(Boolean);
    }catch{
      return [];
    }
  }
  function setFilterList(key, value){
    try{ localStorage.setItem(key, (value || "").trim()); }catch{}
  }
  function applyRandomFilters(files){
    const inc = getFilterList(FILTER_KEY_INCLUDE);
    const exc = getFilterList(FILTER_KEY_EXCLUDE);
    let out = Array.from(files || []);
    if (inc.length){
      out = out.filter(f => {
        const n = getFileNameLower(f);
        return inc.some(t => n.includes(t));
      });
    }
    if (exc.length){
      out = out.filter(f => {
        const n = getFileNameLower(f);
        return !exc.some(t => n.includes(t));
      });
    }
    return out;
  }


  // ====== Undo / Redo (settings only) ======
  const undoStack = [];
  const redoStack = [];
  let pendingSettingsUndo = null;

  function cloneSettings(s){
    return JSON.parse(JSON.stringify(s));
  }
  function captureSettingsUndo(){
    if (!state.selected.has) return;
    const {col,row} = state.selected;
    const cell = state.cells[col][row];
    pendingSettingsUndo = { col, row, before: cloneSettings(cell.settings) };
  }
  function commitSettingsUndo(){
    if (!pendingSettingsUndo) return;
    const {col,row,before} = pendingSettingsUndo;
    const cell = state.cells[col][row];
    const after = cloneSettings(cell.settings);
    pendingSettingsUndo = null;

    if (JSON.stringify(before) === JSON.stringify(after)) return;
    undoStack.push({ type:"settings", col, row, before, after });
    if (undoStack.length > 60) undoStack.shift();
    redoStack.length = 0;
  }
  function applySettingsSnapshot(col, row, snap){
    const cell = state.cells[col][row];
    cell.settings = cloneSettings(snap);
    invalidateCellCache(col,row);
    updateCellUI(col,row);
    if (state.selected.has && state.selected.col===col && state.selected.row===row){
      updateInspector();
    }
  }
  function doUndo(){
    const a = undoStack.pop();
    if (!a) { toast("Nothing to undo", 1200); return; }
    redoStack.push(a);
    applySettingsSnapshot(a.col, a.row, a.before);
    toast("Undo", 900);
  }
  function doRedo(){
    const a = redoStack.pop();
    if (!a) { toast("Nothing to redo", 1200); return; }
    undoStack.push(a);
    applySettingsSnapshot(a.col, a.row, a.after);
    toast("Redo", 900);
  }

// ====== DOM ======
  const colsEl = document.getElementById("cols");
  const specLine = document.getElementById("specLine");
  const toastEl = document.getElementById("toast");

  toastEl.addEventListener("click", () => {
    if (window.__TCM_LAST_FATAL__) showFatal(window.__TCM_LAST_FATAL__);
  });
  const helpOverlayEl = document.getElementById("helpOverlay");
  function getSourcePeaks(entry, w){
    if (!entry) return null;
    if (!entry.peaksByW) entry.peaksByW = new Map();
    if (entry.peaksByW.has(w)) return entry.peaksByW.get(w);
    const p = computePeaks(entry.L, entry.R, w);
    entry.peaksByW.set(w, p);
    return p;
  }


  let waveOverlayEl = null;
  let waveCloseBtnEl = null;
  let wavePlaySelBtnEl = null;
  let wavePlayFullBtnEl = null;
  let waveApplyBtnEl = null;
  let waveSnapBtnEl = null;
  let waveTrimBtnEl = null;
  let waveUndoBtnEl = null;
  let waveResetBtnEl = null;
  let waveBigEl = null;
  let waveTitleEl = null;
  let waveSelStartEl = null;
  let waveSelLenEl = null;
  let waveSrcNameEl = null;
  let waveScissorIconEl = null;

  const waveEditor = {
    open:false,
    undo:[],
    col:0, row:0,
    key:"",
    src:null,
    selStart:0,
    selLen:0,
    dragging:false,
    dragDx:0,
    snap:true,
    mode:"move",
    _px0:0,
    _start0:0,
    _len0:0,
  };

  function ensureWaveEls(){
    if (waveOverlayEl) return true;
    waveOverlayEl   = document.getElementById("waveOverlay");
    waveCloseBtnEl  = document.getElementById("waveCloseBtn");
    wavePlaySelBtnEl = document.getElementById("wavePlaySelBtn");
    wavePlayFullBtnEl = document.getElementById("wavePlayFullBtn");
    waveSnapBtnEl    = document.getElementById("waveSnapBtn");
    waveTrimBtnEl   = document.getElementById("waveTrimBtn");
    waveUndoBtnEl   = document.getElementById("waveUndoBtn");
    waveApplyBtnEl   = document.getElementById("waveApplyBtn");
    waveResetBtnEl  = document.getElementById("waveResetBtn");
    waveBigEl       = document.getElementById("waveBig");
    waveTitleEl     = document.getElementById("waveTitle");
    waveSelStartEl  = document.getElementById("waveSelStart");
    waveSelLenEl    = document.getElementById("waveSelLen");
    waveSrcNameEl   = document.getElementById("waveSrcName");
    waveScissorIconEl = document.querySelector("#waveOverlay .waveScissorIcon");
    return !!(waveOverlayEl && waveBigEl);
  }

  function fmtTime(frames){
    const sec = frames / SR;
    const m = Math.floor(sec / 60);
    const s = sec - m*60;
    return (m>0 ? (m + ":" + String(Math.floor(s)).padStart(2,"0") + "." + String(Math.floor((s%1)*1000)).padStart(3,"0"))
                : (s.toFixed(3) + "s"));
  }

  // ====== Wave Editor draw scheduling (performance) ======
  // Avoid doing multiple full-canvas redraws per pointermove/keydown.
  // We batch redraws to at most once per animation frame.
  let __waveDrawPending = false;
  function scheduleWaveDraw(){
    if (__waveDrawPending) return;
    __waveDrawPending = true;
    requestAnimationFrame(() => {
      __waveDrawPending = false;
      try{ waveDraw(); }catch(err){ try{ showFatal(err); }catch(_){} }
    });
  }

  function waveDraw(){
    if (!ensureWaveEls()) return;
    if (!waveBigEl || !waveEditor.src) return;
    const ctx = waveBigEl.getContext("2d");
    const W = waveBigEl.width;
    const H = waveBigEl.height;
    ctx.clearRect(0,0,W,H);

    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.fillRect(0,0,W,H);

    const peaks = getSourcePeaks(waveEditor.src, W);
    const mid = Math.floor(H/2);
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    const rev = !!(state?.cells?.[waveEditor.col]?.[waveEditor.row]?.settings?.reverse);
    for (let x=0; x<W; x++){
      const ix = rev ? (W-1-x) : x;
      const p = peaks[Math.min(peaks.length-1, ix)];
      const y1 = mid - p*(mid-10);
      const y2 = mid + p*(mid-10);
      ctx.moveTo(x+0.5, y1);
      ctx.lineTo(x+0.5, y2);
    }
    ctx.stroke();

    const total = waveEditor.src.L.length;
    const a = clamp(waveEditor.selStart, 0, Math.max(0, total - waveEditor.selLen));
    const b = a + waveEditor.selLen;

    let x1 = Math.floor((a/total)*W);
    let x2 = Math.max(x1+2, Math.floor((b/total)*W));
    if (rev){
      x1 = Math.floor(((total - b)/total)*W);
      x2 = Math.max(x1+2, Math.floor(((total - a)/total)*W));
    }
    if (x2 < x1){ const t=x1; x1=x2; x2=t; }

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(x1, 0, x2-x1, H);

    ctx.strokeStyle = "rgba(255,255,255,0.65)";
    ctx.lineWidth = 2;
    ctx.strokeRect(x1+1, 1, Math.max(0, x2-x1-2), H-2);

    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.fillRect(x1, 0, 3, H);
    ctx.fillRect(x2-3, 0, 3, H);

    // Handle markers (square grips) to indicate selection edges are draggable
    const hsz = 12, hgap = 3;
    const hm = Math.floor(H/2);
    const hxL = Math.round(x1 - hgap - hsz);
    const hxR = Math.round(x2 + hgap);
    // Brighter, higher-contrast square grips (keep blocky design)
    ctx.fillStyle = "rgba(120,200,255,0.95)";
    ctx.fillRect(hxL, hm - (hsz/2), hsz, hsz);
    ctx.fillRect(hxR, hm - (hsz/2), hsz, hsz);
    ctx.strokeStyle = "rgba(0,0,0,0.60)";
    ctx.lineWidth = 1;
    ctx.strokeRect(hxL + 0.5, hm - (hsz/2) + 0.5, hsz-1, hsz-1);
    ctx.strokeRect(hxR + 0.5, hm - (hsz/2) + 0.5, hsz-1, hsz-1);


    if (waveSelStartEl) waveSelStartEl.textContent = fmtTime(a);
    if (waveSelLenEl) waveSelLenEl.textContent = fmtTime(waveEditor.selLen);
    if (waveSrcNameEl) waveSrcNameEl.textContent = waveEditor.src.name || "sample";
  }

  function openWaveEditor(col, row){
    if (!ensureWaveEls()) { setStatus("Wave editor UI not ready", "warn"); return; }
    const cell = state.cells[col][row];
    // Prefer editing the original full source for split-applied cells, so slice start/length are visible
    let key = "";
    try{
      if (cell && cell.origin && cell.origin.type==="split" && cell.origin.split && cell.origin.split.sourceKey && sourceStore.has(cell.origin.split.sourceKey))
        key = cell.origin.split.sourceKey;
    }catch(_e){}
    if (!key){
      key = ((cell.editorKey && sourceStore.has(cell.editorKey)) ? cell.editorKey : (cell.sourceKey || ""));
    }
    if (!key || !sourceStore.has(key)){
      setStatus("No full source for this cell", "warn");
      return;
    }

    waveEditor.open = true;
    waveEditor.col = col;
    waveEditor.row = row;
    waveEditor.key = key;
    waveEditor.src = sourceStore.get(key);
    waveEditor.undo = Array.isArray(cell.editorUndo) ? cell.editorUndo.slice() : [];
    try{ _waveUndoBtnRefresh(); }catch(_e){}

    try{ if (reverseEl) reverseEl.disabled = true; }catch(_e){}

    const total = waveEditor.src.L.length;
    const cellFrames = getCellFrames(row);
    // Show scissors whenever trimming makes sense (i.e. source > 1 frame)
    if (waveScissorIconEl) waveScissorIconEl.style.display = (total > 1) ? "block" : "none";

    // Allow editor even when source <= cell length: user may want to trim further.
    // Default selection length is the smaller of cellFrames and source length.
    // Default selection length is the smaller of cellFrames and source length.
// Selection init:
// - If this cell has an editorKey (trimmed-in-editor), restore editor selection if present, otherwise full length.
// - Else (full source), restore last applied trim window as selection (non-destructive).
let _selLen = Math.max(1, Math.min(cellFrames, total));
let _selStart = 0;

if (cell.editorKey && cell.editorKey === waveEditor.key){
  if (Number.isFinite(cell.editorSelLen) && cell.editorSelLen > 0){
    _selLen = clamp(Math.round(cell.editorSelLen), 1, total);
  }else{
    _selLen = total;
  }
  if (Number.isFinite(cell.editorSelStart) && cell.editorSelStart >= 0){
    _selStart = Math.round(cell.editorSelStart);
  }else{
    _selStart = 0;
  }
}else{
  if (Number.isFinite(cell.trimLenSrcFrames) && cell.trimLenSrcFrames > 0){
    _selLen = clamp(Math.round(cell.trimLenSrcFrames), 1, total);
  }
  if (Number.isFinite(cell.trimStartSrcFrames) && cell.trimStartSrcFrames >= 0){
    _selStart = Math.round(cell.trimStartSrcFrames);
  }
}

waveEditor.selLen = _selLen;
waveEditor.selStart = clamp(_selStart, 0, Math.max(0, total - waveEditor.selLen));
if (waveTitleEl){
      waveTitleEl.textContent = `Wave Editor · ${getColDisplayName(col)} / ${getCellDisplayName(col, row)}`;
    }
    if (waveSnapBtnEl){
      waveSnapBtnEl.textContent = "Snap: " + (waveEditor.snap ? "on" : "off");
    }

    if (waveOverlayEl){
      waveOverlayEl.style.display = "flex";
      waveOverlayEl.classList.add("show");
      waveOverlayEl.setAttribute("aria-hidden", "false");
      waveOverlayEl.style.zIndex = "34000";
    }
    scheduleWaveDraw();
  }

  function closeWaveEditor(){
magHide();
// Persist editor state for reopen (trim + undo)
    try{
      const _cell = state.cells?.[waveEditor.col]?.[waveEditor.row];
      if (_cell){
        _cell.editorKey = waveEditor.key || _cell.editorKey;
        _cell.editorUndo = Array.isArray(waveEditor.undo) ? waveEditor.undo.slice() : [];
        _cell.editorSelStart = waveEditor.selStart;
        _cell.editorSelLen = waveEditor.selLen;
      }
    }catch(_e){}
    waveEditor.open = false;
    try{ if (reverseEl) reverseEl.disabled = false; }catch(_e){}
    waveEditor.dragging = false;
    if (waveOverlayEl){
      waveOverlayEl.classList.remove("show");
      waveOverlayEl.style.display = "none";
      waveOverlayEl.setAttribute("aria-hidden", "true");
    }
  }

  function commitWaveSelection(){
    const cell = state.cells[waveEditor.col][waveEditor.row];
    // Keep original relink key stable; track the active editor source separately.
    // - When editing the original full source, waveEditor.key equals cell.sourceKey.
    if (waveEditor.key) cell.sourceKey = (cell.sourceKey || waveEditor.key);
cell.selStartFrames = waveEditor.selStart;
    cell.selLenFrames = waveEditor.selLen;
    // keep mini waveform in sync
    try{ markWaveDirty(waveEditor.col, waveEditor.row); }catch(_){ }
  }

  
  function findNearestZeroCrossing(arr, idx, window=2048){
    // Find index near idx where signal is closest to 0 and/or crosses 0.
    if (!arr || !arr.length) return idx;
    const n = arr.length;
    const a = Math.max(1, idx - window);
    const b = Math.min(n-2, idx + window);
    let best = idx;
    let bestAbs = Math.abs(arr[Math.min(n-1, Math.max(0, idx))]);

    for (let i=a; i<=b; i++){
      const v0 = arr[i];
      const v1 = arr[i+1];
      const ab = Math.abs(v0);
      // Prefer actual sign change (crossing), else minimum abs.
      const crossing = (v0 === 0) || (v0 > 0 && v1 < 0) || (v0 < 0 && v1 > 0);
      if (crossing){
        // pick the smaller abs among v0/v1
        const cand = (Math.abs(v0) <= Math.abs(v1)) ? i : (i+1);
        const cab = Math.abs(arr[cand]);
        if (cab <= bestAbs){
          bestAbs = cab;
          best = cand;
        }
      } else if (ab < bestAbs){
        bestAbs = ab;
        best = i;
      }
    }
    return best;
  }

  function waveNudge(framesDelta){
    if (!waveEditor.open || !waveEditor.src) return;
    const total = waveEditor.src.L.length;
    waveEditor.selStart = clamp(
      waveEditor.selStart + framesDelta,
      0,
      Math.max(0, total - waveEditor.selLen)
    );
    commitWaveSelection();
    scheduleWaveDraw();

    // Keep magnifier selection in sync (keyboard nudges have no pointer event)
    try{
      if (typeof _mag !== 'undefined' && _mag && _mag.on){
        const stt = waveEditor.selStart|0;
        const enn = (stt + (waveEditor.selLen|0))|0;
        const ax = magAnchorWave(total|0, stt, enn);
        // In center/move mode, re-anchor the magnifier window to the selection center so it follows nudges
        try{
          if (!(_mag.edge==='L' || _mag.edge==='R')){
            _mag.centerPos = ((stt + enn) >> 1);
          }
        }catch(_e){}
        const y = (typeof _mag.lastYWave==='number') ? _mag.lastYWave : (ax ? ax.y : undefined);
        magUpdate({
          selStart: stt,
          selEnd: enn,
          x: ax ? ax.x : undefined,
          y: y
        });
      }
    }catch(_){ }
  }

  // Nudge selection with awareness of which edge is active in the magnifier.
  // mode: "L" | "R" | "C" (center/move)
  function waveNudgeActive(framesDelta, mode){
    if (!waveEditor.open || !waveEditor.src) return;
    const total = waveEditor.src.L.length|0;
    const minL = 1;
    const cellFrames = getCellFrames(waveEditor.row);
    const maxLen = Math.max(1, Math.min(cellFrames, total));

    let s = waveEditor.selStart|0;
    let l = waveEditor.selLen|0;
    l = clamp(l, 1, Math.min(maxLen, total));
    s = clamp(s, 0, Math.max(0, total - l));

    if (mode === "L"){
      // Move left edge, keep right edge fixed.
      const e = s + l;
      const newS = clamp(s + framesDelta, 0, Math.max(0, e - minL));
      const newL = clamp(e - newS, 1, Math.min(maxLen, total - newS));
      s = newS;
      l = newL;
    } else if (mode === "R"){
      // Move right edge, keep left edge fixed.
      const e0 = s + l;
      const newE = clamp(e0 + framesDelta, s + minL, total);
      const newL = clamp(newE - s, 1, Math.min(maxLen, total - s));
      l = newL;
    } else {
      // Move whole window.
      s = clamp(s + framesDelta, 0, Math.max(0, total - l));
    }

    waveEditor.selStart = s;
    waveEditor.selLen = l;
    commitWaveSelection();
    scheduleWaveDraw();

    // Keep magnifier selection in sync
    try{
      if (typeof _mag !== 'undefined' && _mag && _mag.on && (_mag.srcTag||"")==="wave"){
        const stt = waveEditor.selStart|0;
        const enn = (stt + (waveEditor.selLen|0))|0;
        const ax = magAnchorWave(total|0, stt, enn);
        // In center/move mode, keep magnifier window anchored to the moving selection
        try{
          if (!(_mag.edge==='L' || _mag.edge==='R')){
            _mag.centerPos = ((stt + enn) >> 1);
          }
        }catch(_e){}
        const y = (typeof _mag.lastYWave==='number') ? _mag.lastYWave : (ax ? ax.y : undefined);
        magUpdate({ selStart: stt, selEnd: enn, x: ax ? ax.x : undefined, y });
      }
    }catch(_){ }
  }

async function _playLR(L, R){
    if (!L || !R || !L.length) return;
    await ensureAudio();
    stopPlayback();
    const buf = makeAudioBufferFromLR(L,R);
    const ctx = getAudioCtx();
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.connect(ctx.destination);
    state.currentSrc = src;
    src.start();
    src.onended = () => { if (state.currentSrc === src) state.currentSrc = null; };
  }

  function applyWaveSelectionToCell(){
    // Apply selection: slice full source into the cell's audio buffers (used for playback/export)
    const cell = state.cells[waveEditor.col][waveEditor.row];
    if (!waveEditor.src) return;

    const total = waveEditor.src.L.length;
    let start = clamp(waveEditor.selStart, 0, Math.max(0, total - waveEditor.selLen));
    if (waveEditor.snap){
      start = findNearestZeroCrossing(waveEditor.src.L, start, 4096);
      start = clamp(start, 0, Math.max(0, total - waveEditor.selLen));
    }
    const end = Math.min(total, start + waveEditor.selLen);

    const L = waveEditor.src.L.subarray(start, end);
    const R = waveEditor.src.R.subarray(start, end);

    // Materialize a real copy so it survives even if source arrays are GC'd or reused
    cell.left  = new Float32Array(L);
    cell.right = new Float32Array(R);
// Remember the applied trim window on the ORIGINAL full source (non-destructive metadata for preset export)
cell.trimStartSrcFrames = start;
cell.trimLenSrcFrames   = (end - start);

// --- Mini-wave behavior: only switch the cell's visible source when the user TRIMMED in the editor ---
// If the editor is currently showing a trimmed source (created by the Trim button), we want the cell
// to visually become trimmed too (same as copy behavior). If the user did NOT trim and just hit Apply,
// keep the original full source visible and only update the selection window as before.
const editorIsTrimmed = !!(
  (waveEditor.key && String(waveEditor.key).includes("::trim@")) ||
  (cell.editorKey && String(cell.editorKey).includes("::trim@")) ||
  (Array.isArray(waveEditor.undo) && waveEditor.undo.length > 0)
);

if (editorIsTrimmed){
  // Use the editor's current trimmed source as the cell's visible source
  cell.fullSourceKey = cell.fullSourceKey || (cell.sourceKey || waveEditor.key);
  cell.sourceKey = waveEditor.key;

  // After trimming, selection is the whole trimmed buffer
  cell.selStartFrames = 0;
  cell.selLenFrames   = (end - start);

  // Persist editor state on the cell
  cell.editorKey      = waveEditor.key;
  cell.editorUndo     = Array.isArray(waveEditor.undo) ? waveEditor.undo.slice() : [];
  cell.editorSelStart = 0;
  cell.editorSelLen   = (end - start);
}else{
  // No trim: keep original source visible and store selection window in source-time

  // If we previously applied a Trim (cell.sourceKey points to a trimmed source),
  // and the editor is now back to an untrimmed view (Undo), restore the original full source.
  if (cell.fullSourceKey && sourceStore.has(cell.fullSourceKey)){
    cell.sourceKey = cell.fullSourceKey;
  }
  cell.fullSourceKey = null;

  // No trim: keep original source visible and store selection window in source-time
  // (mini-wave keeps showing full sample + selection overlay)
  cell.selStartFrames = start;
  cell.selLenFrames   = (end - start);

  // Reset editor state to follow the full source for next open
  cell.editorKey      = cell.sourceKey || waveEditor.key;
  cell.editorUndo     = [];
  cell.editorSelStart = cell.selStartFrames;
  cell.editorSelLen   = cell.selLenFrames;
}
// Reset derived caches
    cell.cache = { key:"", L:null, R:null, frames:0 };

    updateCellUI(waveEditor.col, waveEditor.row);
    markWaveDirty(waveEditor.col, waveEditor.row);
    updateInspector(); // keep inspector honest if current cell
    setStatus("Applied selection to cell", "ok");
  }

  function wavePickFromX(clientX){
    const rect = waveBigEl.getBoundingClientRect();
    const px = clamp(clientX - rect.left, 0, rect.width);
    const rev = !!(state?.cells?.[waveEditor.col]?.[waveEditor.row]?.settings?.reverse);
    const t = px / rect.width;
    const tt = rev ? (1 - t) : t;
    const total = waveEditor.src.L.length;
    const start = Math.round(tt * total - waveEditor.selLen/2);
    waveEditor.selStart = clamp(start, 0, Math.max(0, total - waveEditor.selLen));
    commitWaveSelection();
    scheduleWaveDraw();
  }

  function waveDragFromX(clientX){
    const rect = waveBigEl.getBoundingClientRect();
    const px = clamp(clientX - rect.left, 0, rect.width);
    const rev = !!(state?.cells?.[waveEditor.col]?.[waveEditor.row]?.settings?.reverse);
    const t = px / rect.width;
    const tt = rev ? (1 - t) : t;
    const total = waveEditor.src.L.length;
    const start = Math.round(tt * total - waveEditor.dragDx);
    waveEditor.selStart = clamp(start, 0, Math.max(0, total - waveEditor.selLen));
    commitWaveSelection();
    scheduleWaveDraw();
  }

  // Keep handle magnifier responsive while dragging in Wave Editor
  function waveMagSync(clientX, clientY){
    try{
      if (typeof _mag === 'undefined' || !_mag || !_mag.on) return;
      if ((_mag.srcTag||"") !== "wave") return;
      if (!waveEditor.open || !waveEditor.src) return;
      const total = waveEditor.src.L.length|0;
      const stt = waveEditor.selStart|0;
      const enn = (stt + (waveEditor.selLen|0))|0;
      const ax = magAnchorWave(total|0, stt, enn);
      // If magnifier is in center/move mode, keep its anchor following the moving selection
      try{
        if (typeof _mag !== 'undefined' && _mag && _mag.on && (_mag.srcTag||"")==='wave' && !(_mag.edge==='L' || _mag.edge==='R')){
          _mag.centerPos = ((stt + enn) >> 1);
        }
      }catch(_e){}
      magUpdate({
        selStart: stt,
        selEnd: enn,
        x: (ax && typeof ax.x === "number") ? ax.x : clientX,
        y: clientY
      });
    }catch(_){ }
  }

  
  // ===== Column Split Editor (Load+Slice) =====
  const splitStateByCol = new Map(); // col -> {sourceKey, blocks:[{s,l}], undo:[]}
  let splitOverlayEl = null, splitTitleEl=null, splitBigEl=null;

  // HARD ESC GUARD — Slice Editor: ESC closes zoom first, then editor
  window.addEventListener("keydown", (e) => {
    if (e.key !== "Escape") return;
    try{
      const splitOpen = (splitOverlayEl && splitOverlayEl.style.display !== "none");
      if (!splitOpen) return;

      const el = document.getElementById("tcmMag");
      const magVisible = !!(el && el.style.display !== "none");

      if (magVisible){
        magHide();
    // avoid focusing Load+Slice button behind overlay
    try{
      const ae = document.activeElement;
      if (ae && ae.tagName === "BUTTON" && splitOverlayEl && !splitOverlayEl.contains(ae)) ae.blur();
    }catch(__){}
} else {
        splitClose();
      }

      e.preventDefault();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      e.stopPropagation();
      return;
    }catch(_e){
      // If anything goes wrong, fall back to closing editor (never crash)
      try{ splitClose(); }catch(__){}
      try{
        e.preventDefault();
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
        e.stopPropagation();
      }catch(__){}
    }
  }, true);

  function getColDisplayName(c){
    const v = (state.colNames && state.colNames[c] != null) ? String(state.colNames[c]).trim() : "";
    return v ? v : `Sample ${c+1}`;
  }
  function getCellDisplayName(c, r){
    const v = (state.cellNames && state.cellNames[c] && state.cellNames[c][r] != null) ? String(state.cellNames[c][r]).trim() : "";
    return v ? v : `C${r+1}`;
  }
  function splitUpdateTitle(){
    if (!splitTitleEl) return;
    // Title stays simple; names live in the info row.
    splitTitleEl.textContent = 'Slice Editor';
  }

  let splitSelStartEl=null, splitSelLenEl=null, splitSrcNameEl=null, splitNameEl=null;
  let splitLoadBtnEl=null, splitAutoBtnEl=null, splitPlaySelBtnEl=null, splitPlayFullBtnEl=null, splitUndoBtnEl=null, splitApplyBtnEl=null, splitCloseBtnEl=null, splitHintEl=null;
  let splitCol = 0;
  let splitDragging = null;
let splitPointerId = null; let splitActiveIdx = 0;
      splitUpdateTitle();
// {i, mode, startX, origS, origL}
  let splitRAF = 0;

  function splitEnsureEls(){
    if (splitOverlayEl) return;
    splitOverlayEl = document.getElementById("splitOverlay");
    splitTitleEl = document.getElementById("splitTitle");
    splitBigEl = document.getElementById("splitBig");
    splitLoadBtnEl = document.getElementById("splitLoadBtn");
    splitAutoBtnEl = document.getElementById("splitAutoBtn");
    splitPlaySelBtnEl = document.getElementById("splitPlaySelBtn");
    splitPlayFullBtnEl = document.getElementById("splitPlayFullBtn");
    splitUndoBtnEl = document.getElementById("splitUndoBtn");
    splitApplyBtnEl = document.getElementById("splitApplyBtn");
    splitCloseBtnEl = document.getElementById("splitCloseBtn");
    splitHintEl = document.getElementById("splitHint");
    splitSelStartEl = document.getElementById("splitSelStart");
    splitSelLenEl   = document.getElementById("splitSelLen");
    splitSrcNameEl  = document.getElementById("splitSrcName");
    splitNameEl     = document.getElementById("splitName");
    if (splitHintEl && !splitHintEl.innerHTML.includes("Space")){
      splitHintEl.innerHTML += " • <b>Space</b> plays the focused slice";
    }
  }

  function splitUpdateMeta(){
    splitEnsureEls();
    if (!splitSelStartEl || !splitSelLenEl || !splitSrcNameEl) return;
    if (splitNameEl){
      splitNameEl.textContent = `${getColDisplayName(splitCol)} / ${getCellDisplayName(splitCol, splitActiveIdx)}`;
    }
    const st = splitGetState(splitCol);
    const src = (st && st.sourceKey) ? sourceStore.get(st.sourceKey) : null;
    const cName = getColDisplayName(splitCol);
    const rName = getCellDisplayName(splitCol, splitActiveIdx);
    if (splitNameEl) splitNameEl.textContent = `${cName} / ${rName}`;
    if (!src || !src.L){
      if (splitNameEl) splitNameEl.textContent = `${getColDisplayName(splitCol)} / ${getCellDisplayName(splitCol, splitActiveIdx)}`;
      splitSelStartEl.textContent = "—";
      splitSelLenEl.textContent   = "—";
      splitSrcNameEl.textContent  = "—";
      return;
    }
    const b = st.blocks[splitActiveIdx] || {s:0,l:0};
    splitSelStartEl.textContent = fmtTime(b.s|0);
    splitSelLenEl.textContent   = fmtTime(b.l|0);
    splitSrcNameEl.textContent  = (src.name || "sample");
  }

  function splitGetState(col){
    let st = splitStateByCol.get(col);
    if (!st){
      st = { sourceKey:null, blocks: new Array(8).fill(0).map(()=>({s:0,l:0})), undo:[] };
      splitStateByCol.set(col, st);
    }
    return st;
  }

  function splitCellMaxFrames(){
    // same max frames for all rows in current timing mode
    return getCellFrames(0);
  }

  function splitPushUndo(){
    const st = splitGetState(splitCol);
    st.undo.push(st.blocks.map(b=>({s:b.s,l:b.l})));
    if (st.undo.length>50) st.undo.shift();
    if (splitUndoBtnEl) splitUndoBtnEl.disabled = (st.undo.length===0);
  }
  function splitUndo(){
    const st = splitGetState(splitCol);
    if (!st.undo.length) return;
    const prev = st.undo.pop();
    st.blocks = prev.map(b=>({s:b.s,l:b.l}));
    splitStateByCol.set(splitCol, st);
    if (splitUndoBtnEl) splitUndoBtnEl.disabled = (st.undo.length===0);
    splitScheduleDraw();
  }

  function splitAutoTile(){
    const st = splitGetState(splitCol);
    const src = st.sourceKey ? sourceStore.get(st.sourceKey) : null;
    if (!src || !src.L) return;
    const total = src.L.length|0;
    const cellMax = splitCellMaxFrames();

    // Equal distribution across the full sample length,
    // but each block is clamped to the max cell length.
    const rawLen = Math.max(1, Math.floor(total/8));
    const blockLen = Math.min(cellMax, rawLen);
    const span = Math.max(0, total - blockLen);
    for (let i=0;i<8;i++){
      const start = (i===7) ? span : Math.round((i/7) * span);
      st.blocks[i].s = start;
      st.blocks[i].l = Math.min(blockLen, Math.max(1, total - start));
    }
    splitScheduleDraw();
  }

  function splitOpen(col){
    splitEnsureEls();
    splitCol = col|0;
    splitUpdateTitle();
    splitOverlayEl.style.display = "flex";
    splitOverlayEl.classList.add("show");
    splitOverlayEl.setAttribute("aria-hidden","false");
    const st = splitGetState(splitCol);
    splitUndoBtnEl.disabled = (st.undo.length===0);
    splitHintEl.innerHTML = st.sourceKey
      ? 'Drag or resize the 8 selection blocks (each is limited to the max cell length). '
        + 'Click a block to focus it, then use the zoom window for precise edits. '
        + '<br><span class="muted"><b>Auto</b> tiles 8 blocks evenly • <b>Undo</b> reverts the last edit • <b>Apply</b> writes the slices into the column.</span>'
      : '<span class="muted">Load a sample</span><br><span class="muted"><b>Auto</b> tiles blocks across the waveform. <b>Apply</b> fills the column.</span>';
    splitScheduleDraw();
  }
  function splitClose(){
magHide();
splitEnsureEls();
    // Make sure we fully release any pointer capture so mouse works again after closing/apply
    if (splitPointerId!==null){
      try{ splitBigEl.releasePointerCapture(splitPointerId); }catch(e){}
      splitPointerId=null;
    }
    splitDragging=null;
    splitOverlayEl.style.display="none";
    splitOverlayEl.setAttribute("aria-hidden","true");
        splitOverlayEl.classList.remove("show");
// Reset cursor just in case
    try{ splitBigEl.style.cursor=""; }catch(e){}
  }

  function openSplitEditor(col){
    const c = col|0;
    const st = splitGetState(c);
    // Nicer flow: first pick/load a sample, then open the editor.
    if (!st.sourceKey){
      splitCol = c;
      splitPickSample(c);
      return;
    }
    splitOpen(c);
  }

  function splitPickSample(colOverride){
    const col = (colOverride!=null) ? (colOverride|0) : (splitCol|0);
    state.pick = { kind:"splitEditor", col, row:null };
    fileInput.value="";
    fileInput.multiple=false;
    fileInput.click();
  }

  function splitScheduleDraw(){
    if (!splitBigEl) return;
    if (splitRAF) return;
    splitRAF = requestAnimationFrame(()=>{ splitRAF=0; splitDraw(); });
  }

  function splitFramesToX(frames, srcLen, w){ return srcLen? (frames/srcLen)*w : 0; }
  function splitXToFrames(x, srcLen, w){
    if (!w) return 0;
    const t = Math.max(0, Math.min(1, x/w));
    return Math.round(t*srcLen);
  }

  function splitClampBlock(st, i){
    const src = st.sourceKey ? sourceStore.get(st.sourceKey) : null;
    if (!src || !src.L) return;
    const total = src.L.length|0;
    const cellMax = splitCellMaxFrames();
    const b = st.blocks[i];
    b.s = Math.max(0, Math.min(b.s, Math.max(0,total-1)));
    b.l = Math.max(1, Math.min(b.l, cellMax));
    if (b.s + b.l > total) b.l = Math.max(1, total - b.s);
  }

  
  
function splitNudgeActive(dirSamples, mode){
  try{
    const st = splitGetState(splitCol);
    const i = splitActiveIdx|0;
    const b = st.blocks[i];
    if (!b) return false;
    const src = sourceStore.get(st.sourceKey);
    const total = (src && src.L) ? (src.L.length|0) : 0;
    if (!total) return false;

    const s0 = b.s|0;
    const l0 = b.l|0;
    const minL = 1;

    if (mode === "L"){
      const newS = magClamp(s0 + dirSamples, 0, s0 + l0 - minL);
      b.l = (s0 + l0) - newS;
      b.s = newS;
    } else if (mode === "R"){
      const newE = magClamp((s0 + l0) + dirSamples, s0 + minL, total);
      b.l = newE - s0;
    } else {
      const newS = magClamp(s0 + dirSamples, 0, total - l0);
      b.s = newS;
    }

    splitClampBlock(st, i);
    splitDraw();
    return true;
  }catch(_){
    return false;
  }
}

function splitPlayActiveSlice(){
    if (!splitOverlayEl || splitOverlayEl.style.display === "none") return;
    const st = splitGetState(splitCol|0);
    if (!st || !st.sourceKey || !sourceStore.has(st.sourceKey)) { toast("No sample loaded", "warn"); return; }
    const src = sourceStore.get(st.sourceKey);
    const b = st.blocks[splitActiveIdx|0];
    if (!b) return;
    const start = Math.max(0, b.s|0);
    const end = Math.min(src.L.length, start + (b.l|0));
    if (end <= start+1) return;
    // toggle play/stop
    if (state.currentSrc){ stopPlayback(); return; }
    const L = src.L.subarray(start, end);
    const R = src.R.subarray(start, end);
    _playLR(L, R);
  }

function splitDraw(){
    splitEnsureEls();
    const ctx = splitBigEl.getContext("2d");
    const w = splitBigEl.width|0;
    const h = splitBigEl.height|0;
    ctx.clearRect(0,0,w,h);

    // bg
    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.fillRect(0,0,w,h);

    const st = splitGetState(splitCol);
    const src = st.sourceKey ? sourceStore.get(st.sourceKey) : null;
    if (!src || !src.L){
      if (splitNameEl) splitNameEl.textContent = `${getColDisplayName(splitCol)} / ${getCellDisplayName(splitCol, splitActiveIdx)}`;
      ctx.fillStyle="rgba(255,255,255,0.75)";
      ctx.font="14px system-ui, sans-serif";
      ctx.fillText("Load a sample to split…", 12, 26);
      splitUpdateMeta();
      return;
    }
    const srcLen = src.L.length|0;

    // waveform peaks
    const peaks = getSourcePeaks(src, w);
    const mid = (h*0.50)|0;
    ctx.strokeStyle = "rgba(230,230,230,0.78)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x=0;x<w;x++){
      const p = peaks[x] || 0;
      const y = Math.max(1, Math.round(p*(h*0.42)));
      ctx.moveTo(x, mid-y);
      ctx.lineTo(x, mid+y);
    }
    ctx.stroke();

    // selections: 8 bands
    const padTop = 10;
    const bandH = Math.floor((h - padTop - 8)/8);
    const cellMax = splitCellMaxFrames();
    const maxSec = (cellMax/48000);
    for (let i=0;i<8;i++){
      const b = st.blocks[i];
      const y0 = padTop + i*bandH;
      const y1 = y0 + bandH - 3;
      const xs = splitFramesToX(b.s, srcLen, w);
      const xl = splitFramesToX(b.l, srcLen, w);
      const xr = xs + xl;

      // label inside block (subtle, moves with the block)
      const labelX = Math.min(w-40, Math.max(6, xs + 8));
      ctx.fillStyle="rgba(255,255,255,0.42)";
      ctx.font="11px system-ui, sans-serif";
      ctx.fillText(`C${i+1}`, labelX, y0+13);

      // rect
      ctx.fillStyle="rgba(120,200,255,0.10)";
      ctx.fillRect(xs, y0, Math.max(0,xl), (y1-y0));
      if (i===splitActiveIdx){
        ctx.strokeStyle="rgba(170,210,255,0.95)";
        ctx.lineWidth=2;
      }else{
        ctx.strokeStyle="rgba(255,255,255,0.50)";
        ctx.lineWidth=1;
      }
      ctx.strokeRect(xs+0.5, y0+0.5, Math.max(0,xl)-1, (y1-y0)-1);
// handles (outside square grips, visually integrated)
      const hm = ((y0+y1)/2)|0;
      const hsz = 6;
      const hgap = 2; // gap outside block
      // grips sit just OUTSIDE the block edge, but visually "attached"
      const hxL = xs - hsz - hgap;
      const hxR = xr + hgap;
      ctx.fillStyle = "rgba(235,235,235,0.88)";
      ctx.fillRect(hxL, hm - (hsz>>1), hsz, hsz);
      ctx.fillRect(hxR, hm - (hsz>>1), hsz, hsz);
      // outline grips with same stroke as block
      ctx.strokeStyle="rgba(255,255,255,0.55)";
      ctx.lineWidth=1;
      ctx.strokeRect(hxL+0.5, hm - (hsz>>1) + 0.5, hsz-1, hsz-1);
      ctx.strokeRect(hxR+0.5, hm - (hsz>>1) + 0.5, hsz-1, hsz-1);
      // max len text
      ctx.fillStyle="rgba(255,255,255,0.45)";
      ctx.font="10px system-ui, sans-serif";
    }

    // keep the info row in sync with the focused slice
    splitUpdateMeta();
  }

  function splitHit(ev){
    splitEnsureEls();
    const rect = splitBigEl.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (splitBigEl.width / (rect.width||1));
    const y = (ev.clientY - rect.top) * (splitBigEl.height / (rect.height||1));
    const st = splitGetState(splitCol);
    const src = st.sourceKey ? sourceStore.get(st.sourceKey) : null;
    if (!src || !src.L) return null;

    const padTop=10;
    const h=splitBigEl.height|0;
    const bandH = Math.floor((h - padTop - 8)/8);
    const i = Math.max(0, Math.min(7, Math.floor((y - padTop)/bandH)));
    const y0 = padTop + i*bandH;
    const y1 = y0 + bandH - 3;
    if (y < y0 || y > y1) return null;

    const srcLen = src.L.length|0;
    const b = st.blocks[i];
    const w = splitBigEl.width|0;
    const xs = splitFramesToX(b.s, srcLen, w);
    const xl = splitFramesToX(b.l, srcLen, w);
    const xr = xs + xl;
    // hit areas:
    // - big circular zones at left/right (outside the block) for resize
    // - inside the block = move
    const hm = (y0+y1)/2;
    const r = 36; // radius in canvas px (easier to grab)
    const hsz = 6, hgap = 2;
    const cxL = xs - hgap - (hsz/2);
    const cxR = xr + hgap + (hsz/2);
    const dxL = x - cxL, dyL = y - hm;
    const dxR = x - cxR, dyR = y - hm;
    let mode = null;
    // left/right resize zones: generous vertically, but capped horizontally so it doesn't spill into the block
    const capIn0 = 10; // px allowed inside the block edge
    const vBand = 28; // px vertical half-band around handle center

    // When blocks get very narrow (e.g. short samples), left/right hit zones can overlap and "move" becomes unreachable.
    // Guarantee a usable middle zone by shrinking capIn, or forcing move when too narrow.
    const pxW = Math.max(0, xr - xs);
    const minMid = 12; // minimum middle width in px
    let capIn = capIn0;
    if (pxW > 0 && pxW < (capIn0*2 + minMid)){
      capIn = Math.max(2, Math.floor((pxW - minMid)/2));
    }
    const hasMiddle = (pxW >= (capIn*2 + minMid));

    if (!hasMiddle){
      // Too tight: treat any click inside the block as MOVE. Resize is still available via zoom (L/R) + keys.
      if (x >= xs && x <= xr) mode = "move";
      else return null;
    } else if (x <= xs + capIn && Math.abs(dyL) <= vBand && Math.abs(dxL) <= (r*0.85)) mode = "left";
    else if (x >= xr - capIn && Math.abs(dyR) <= vBand && Math.abs(dxR) <= (r*0.85)) mode = "right";
    else if (x >= xs && x <= xr) mode = "move";
    else return null;
    // Pick which part of the block the zoom window should show (L/M/R)
    // independent of drag mode. This stays usable even when blocks touch.
    let edge = 'C';
    if (x >= xs && x <= xr){
      const t = (x - xs) / Math.max(1, (xr - xs));
      edge = (t < 0.333) ? 'L' : (t > 0.666 ? 'R' : 'C');
    } else if (mode==='left') edge = 'L';
    else if (mode==='right') edge = 'R';

    return {i, mode, x, edge};
  }

  function splitAttachHandlers(){
    splitEnsureEls();
    splitCloseBtnEl.addEventListener("click", splitClose);
    splitLoadBtnEl.addEventListener("click", splitPickSample);
    splitAutoBtnEl.addEventListener("click", ()=>{ const st=splitGetState(splitCol); if(!st.sourceKey) return; splitPushUndo(); splitAutoTile(); });

    splitPlaySelBtnEl?.addEventListener("click", (e)=>{
      e.preventDefault();
      try{ e.currentTarget && e.currentTarget.blur && e.currentTarget.blur(); }catch(_){ }
      try{ splitPlayActiveSlice(); } catch(err){ console.error(err); toast((err && err.message) ? err.message : String(err), 6500); }
    });
    splitPlayFullBtnEl?.addEventListener("click", (e)=>{
      e.preventDefault();
      try{ e.currentTarget && e.currentTarget.blur && e.currentTarget.blur(); }catch(_){}
      try{
        const st = splitGetState(splitCol|0);
        if (!st || !st.sourceKey || !sourceStore.has(st.sourceKey)) { toast("No sample loaded", "warn"); return; }
        const src = sourceStore.get(st.sourceKey);
        // toggle play/stop
        if (state.currentSrc){ stopPlayback(); return; }
        _playLR(src.L, src.R);
      }catch(err){
        console.error(err);
        toast((err && err.message) ? err.message : String(err), 6500);
      }
    });
    splitUndoBtnEl.addEventListener("click", splitUndo);
    splitApplyBtnEl.addEventListener("click", ()=>{
      const col = splitCol|0;
      const st = splitGetState(col);
      if (!st.sourceKey){
        toast("Load a sample first.");
        return;
      }
      const src = sourceStore.get(st.sourceKey);
      if (!src || !src.L){
      if (splitNameEl) splitNameEl.textContent = `${getColDisplayName(splitCol)} / ${getCellDisplayName(splitCol, splitActiveIdx)}`;
        toast("Source missing.");
        return;
      }
      const srcLen = src.L.length|0;
      const srcName = (src.name || "sample").toString();

      for (let r=0;r<8;r++){
        const b = st.blocks[r];
        const start = clamp(b.s|0, 0, Math.max(0, srcLen-1));
        const len = clamp(b.l|0, 1, Math.max(1, srcLen-start));
        const end = Math.min(srcLen, start + len);

        const cell = state.cells[col][r];
        cell.cache = { key:"", L:null, R:null, frames:0 };
        cell.sourceKey = st.sourceKey;

        const Lseg = src.L.subarray(start, end);
        const Rseg = src.R.subarray(start, end);
        cell.left  = new Float32Array(Lseg);
        cell.right = new Float32Array(Rseg);


        
        // Store this slice as an editor source so Wave Editor can open even if it exactly matches cell length
        const ek = `splitSlice:${col}:${r}:${Date.now()}:${Math.random().toString(16).slice(2)}`;
        sourceStore.set(ek, { L: cell.left, R: cell.right, SR: SR, name: (typeof splitSrcName!=='undefined' && splitSrcName) ? splitSrcName : "split slice" });
        cell.editorKey = ek;
        cell.allowWaveEditor = true;
        // Reset Wave Editor trim/undo state when overwriting via Load+Slice Apply
        cell.editorUndo = [];
        cell.editorTrimmed = false;
        cell.editorSelStart = null;
        cell.editorSelLen = null;
        // Reset cell selection to full cell length after split overwrite
        const cf = getCellFrames(r)|0;
        cell.selStart = 0;
        cell.selLen = cf;
// This cell now owns its audio buffers (do not reference full source for mini-wave)
        cell.sourceKey = null;
        cell.sourceMeta = null;
        // Remember slice window on ORIGINAL source so preset export/import can reconstruct the slices
        cell.selStartFrames = start;
        cell.selLenFrames   = (end - start);
        cell.trimStartSrcFrames = start;
        cell.trimLenSrcFrames   = (end - start);
        // Cell label in the matrix: file name + user cell name (defaults to "Cell N")
        cell.name = `${srcName} · ${getCellDisplayName(splitCol, r)}`;
        cell.origin = {
          type:"split",
          fileName: srcName,
          relPath: (cell.origin && cell.origin.relPath) ? cell.origin.relPath : "",
          split: { sourceKey: st.sourceKey, startFrames: start, lenFrames: (end-start), col, row:r }
        };

        cell.peaks = computePeaks(cell.left, cell.right, MINI_PEAKS_POINTS);

        invalidateCellCache(col, r);
        updateCellUI(col, r);
        markWaveDirty(col, r);
}
      updateColUI(col);
      toast(`Applied split to column ${col+1}`);
      splitClose();
    });
splitBigEl.addEventListener("pointerdown", (ev)=>{
      const hit = splitHit(ev);
      if (!hit) { try{ magHide(); }catch(_){ } return; }
ev.preventDefault();
      const st = splitGetState(splitCol);
      splitPushUndo();
      const b = st.blocks[hit.i];
      const prevIdx = splitActiveIdx;
      if (prevIdx !== hit.i){ try{ magHide(); }catch(_){ } }
      splitActiveIdx = hit.i;
      splitDraw();
      
      // Auto magnifier on dense waveforms (click anywhere on block)
      try{
        const st = splitGetState(splitCol);
        if (st && st.sourceKey && sourceStore.has(st.sourceKey)){
          const src = sourceStore.get(st.sourceKey);
          const Wm = splitBigEl.width|0;
          const density = (src.L.length|0) / Math.max(1, Wm);
          if (true){
            const bb = st.blocks[hit.i];
            const selStart = bb.s|0;
            const selEnd = (bb.s|0) + (bb.l|0);
            const edge = (hit && hit.edge) ? hit.edge : ((hit.mode==="left") ? "L" : (hit.mode==="right" ? "R" : "C"));
            magShow({tag:"split", src, total:(src.L.length|0), selStart, selEnd, edge:edge, x: ev.clientX, y: ev.clientY,
              label: (edge==="L"?"Resize L":(edge==="R"?"Resize R":"Move")) + "  (Esc: hide zoom)"});
          } else {
          }
        }
      }catch(_){}
splitDragging = {i: hit.i, mode: hit.mode, startX: hit.x, origS: b.s, origL: b.l};
      
      if (hit.mode === "left" || hit.mode === "right"){
        try{
          if (st && st.sourceKey && sourceStore.has(st.sourceKey)){
            const src = sourceStore.get(st.sourceKey);
            const total = src.L.length|0;
            const bb = st.blocks[hit.i];
            const selStart = bb.s|0;
            const selEnd = (bb.s|0) + (bb.l|0);
            magShow({tag:"split", src, total, selStart, selEnd, edge: (hit && hit.edge) ? hit.edge : (hit.mode==="left"?"L":"R"), x: ev.clientX, y: ev.clientY,
              label: (hit.mode==="left"?"Resize L":"Resize R") + "  (Space: play sel)"});
          }
        }catch(_){ }
      }
splitPointerId = ev.pointerId;
      splitBigEl.setPointerCapture(ev.pointerId);
    });
    splitBigEl.addEventListener("pointermove", (ev)=>{
      if (!splitDragging) return;
      const rect = splitBigEl.getBoundingClientRect();
      const x = (ev.clientX - rect.left) * (splitBigEl.width / (rect.width||1));
      const st = splitGetState(splitCol);
      const src = st.sourceKey ? sourceStore.get(st.sourceKey) : null;
      if (!src || !src.L) return;
      const srcLen = src.L.length|0;
      const w = splitBigEl.width|0;
      const dx = splitXToFrames(x, srcLen, w) - splitXToFrames(splitDragging.startX, srcLen, w);
      const b = st.blocks[splitDragging.i];
      if (splitDragging.mode==="move"){
        b.s = splitDragging.origS + dx;
      }else if (splitDragging.mode==="left"){
        const maxLen = getCellFrames(splitDragging.i)|0;
        const end = splitDragging.origS + splitDragging.origL;
        const newStart = splitDragging.origS + dx;
        const wantedLen = end - newStart;
        if (wantedLen > maxLen && dx < 0){
          b.s = splitDragging.origS + dx;
          b.l = maxLen;
        }else{
          b.s = Math.min(end-1, newStart);
          b.l = Math.max(1, Math.min(maxLen, wantedLen));
        }
      }else if (splitDragging.mode==="right"){
        const maxLen = getCellFrames(splitDragging.i)|0;
        const wanted = splitDragging.origL + dx;
        if (wanted > maxLen && dx > 0){
          b.s = splitDragging.origS + dx;
          b.l = maxLen;
        }else{
          b.l = Math.max(1, Math.min(maxLen, wanted));
        }
      }
      splitClampBlock(st, splitDragging.i);
      splitScheduleDraw();
    
      
      if (_mag.on){
        try{
          const bb = st.blocks[splitDragging.i];
          const ax = magAnchorSplit((sourceStore.get(st.sourceKey).L.length|0), bb);
          magUpdate({selStart:(bb.s|0), selEnd:((bb.s|0)+(bb.l|0)), x: ax? ax.x : ev.clientX, y: ev.clientY});
        }catch(_){}
      }
if (_mag.on && (splitDragging.mode==="left" || splitDragging.mode==="right")){
        try{
          const bb = st.blocks[splitDragging.i];
          magUpdate({selStart:(bb.s|0), selEnd:((bb.s|0)+(bb.l|0)), x: ev.clientX, y: ev.clientY});
        }catch(_){ }
      }
});
    splitBigEl.addEventListener("pointerup", (ev)=>{ 
if(!splitDragging) return; splitDragging=null; try{ splitBigEl.releasePointerCapture(ev.pointerId);}catch(e){} splitPointerId=null; });
    splitBigEl.addEventListener("pointercancel", ()=>{ splitDragging=null; splitPointerId=null; try{splitBigEl.releasePointerCapture(splitPointerId);}catch(e){} });
  }

function waveAttachHandlers(){
    if (!ensureWaveEls()) return;
    // elements are resolved lazily via ensureWaveEls()

    waveCloseBtnEl?.addEventListener("click", (e)=>{ e.preventDefault(); closeWaveEditor(); });

    wavePlaySelBtnEl?.addEventListener("click", async (e)=>{ 
      e.preventDefault();
      if (!waveEditor.src) return;
      const cell = getCell(waveEditor.col, waveEditor.row);
      const isRev = !!(cell && cell.settings && cell.settings.reverse);

      const total = waveEditor.src.L.length;
      const start = clamp(waveEditor.selStart, 0, Math.max(0, total - waveEditor.selLen));
      const end = Math.min(total, start + waveEditor.selLen);

      let L = waveEditor.src.L.subarray(start, end);
      let R = waveEditor.src.R.subarray(start, end);

      if (isRev) {
        // Reverse audition to match cell playback when Reverse is enabled.
        const n = end - start;
        const rL = new Float32Array(n);
        const rR = new Float32Array(n);
        for (let i = 0, j = n - 1; i < n; i++, j--) {
          rL[i] = L[j];
          rR[i] = R[j];
        }
        L = rL; R = rR;
      }

      await _playLR(L, R);
    });


    waveSnapBtnEl?.addEventListener("click", (e)=>{ 
      e.preventDefault();
      waveEditor.snap = !waveEditor.snap;
      if (waveSnapBtnEl) waveSnapBtnEl.textContent = "Snap: " + (waveEditor.snap ? "on" : "off");
    });

    wavePlayFullBtnEl?.addEventListener("click", async (e)=>{ 
      e.preventDefault();
      if (!waveEditor.src) return;
      const cell = getCell(waveEditor.col, waveEditor.row);
      const isRev = !!(cell && cell.settings && cell.settings.reverse);

      if (!isRev) {
        await _playLR(waveEditor.src.L, waveEditor.src.R);
        return;
      }

      // Reverse audition to match cell playback when Reverse is enabled.
      const n = waveEditor.src.L.length;
      const rL = new Float32Array(n);
      const rR = new Float32Array(n);
      for (let i = 0, j = n - 1; i < n; i++, j--) {
        rL[i] = waveEditor.src.L[j];
        rR[i] = waveEditor.src.R[j];
      }
      await _playLR(rL, rR);
    });

    waveApplyBtnEl?.addEventListener("click", (e)=>{
      e.preventDefault();
      applyWaveSelectionToCell();
      closeWaveEditor();
    });

    waveResetBtnEl?.addEventListener("click", (e)=>{
      e.preventDefault();
      if (!waveEditor.src) return;
      const total = waveEditor.src.L.length|0;
      const cellFrames = getCellFrames(waveEditor.row);
      // Reset to the maximum usable selection for this cell (cell length, capped by source length)
      waveEditor.selStart = 0;
      waveEditor.selLen = Math.max(1, Math.min(cellFrames|0, total));
      commitWaveSelection();
      scheduleWaveDraw();
    });

    // --- Trim & Undo (Wave Editor) ---
    function _getWaveEditorCell(){
      try{ return state.cells[waveEditor.col][waveEditor.row]; }catch(_e){ return null; }
    }
    function _waveUndoBtnRefresh(){
      if (!waveUndoBtnEl) return;
      waveUndoBtnEl.disabled = !(waveEditor.undo && waveEditor.undo.length);
    }

    function waveEditorTrimToSelection(){
      const cell = _getWaveEditorCell();
      if (!cell || !waveEditor.src) return;
      const total = waveEditor.src.L.length;
      const len = clamp(Math.round(waveEditor.selLen||0), 1, total);
      const start = clamp(Math.round(waveEditor.selStart||0), 0, Math.max(0, total - len));
      const end = Math.min(total, start + len);

      // Push undo snapshot (key + selection)
      waveEditor.undo = waveEditor.undo || [];
      waveEditor.undo.push({ key: waveEditor.key, selStart: waveEditor.selStart, selLen: waveEditor.selLen });

      // Slice and materialize new source
      const nL = new Float32Array(waveEditor.src.L.subarray(start, end));
      const nR = new Float32Array(waveEditor.src.R.subarray(start, end));
      const newKey = waveEditor.key + "::trim@" + Date.now();
      sourceStore.set(newKey, {
        name: (waveEditor.src.name || "sample") + " · trimmed",
        L: nL, R: nR,
        peaksByW: new Map()
      });

      waveEditor.key = newKey;
      waveEditor.src = sourceStore.get(newKey);
      waveEditor.selStart = 0;
      waveEditor.selLen = nL.length;

      // Persist editor state on the cell (so reopening shows trimmed, but undo remains possible)
      cell.editorKey = newKey;
      cell.editorUndo = waveEditor.undo.slice();
      cell.editorSelStart = waveEditor.selStart;
      cell.editorSelLen = waveEditor.selLen;

      _waveUndoBtnRefresh();
      commitWaveSelection();
      scheduleWaveDraw();
    }

    function waveEditorUndoTrim(){
      const cell = _getWaveEditorCell();
      if (!cell || !waveEditor.undo || !waveEditor.undo.length) return;
      const prev = waveEditor.undo.pop();
      if (!prev || !prev.key || !sourceStore.has(prev.key)) { _waveUndoBtnRefresh(); return; }

      waveEditor.key = prev.key;
      waveEditor.src = sourceStore.get(prev.key);
      waveEditor.selStart = clamp(Math.round(prev.selStart||0), 0, Math.max(0, waveEditor.src.L.length - 1));
      waveEditor.selLen = clamp(Math.round(prev.selLen||1), 1, waveEditor.src.L.length);

      cell.editorKey = waveEditor.key;
      cell.editorUndo = waveEditor.undo.slice();
      cell.editorSelStart = waveEditor.selStart;
      cell.editorSelLen = waveEditor.selLen;

      _waveUndoBtnRefresh();
      commitWaveSelection();
      scheduleWaveDraw();
    }

    waveTrimBtnEl?.addEventListener("click", (e)=>{
      e.preventDefault();
      waveEditorTrimToSelection();
    });

    waveUndoBtnEl?.addEventListener("click", (e)=>{
      e.preventDefault();
      waveEditorUndoTrim();
    });


    waveOverlayEl.addEventListener("click", (e)=>{ if (e.target === waveOverlayEl) closeWaveEditor(); });

    waveBigEl.addEventListener("pointerdown", (e)=>{
      if (!waveEditor.open) return;
      waveBigEl.setPointerCapture(e.pointerId);
      waveEditor.dragging = true;

      const rect = waveBigEl.getBoundingClientRect();
      const W = rect.width;
      const total = waveEditor.src.L.length;

      const rev = !!(state?.cells?.[waveEditor.col]?.[waveEditor.row]?.settings?.reverse);
      const a = clamp(waveEditor.selStart, 0, Math.max(0, total - waveEditor.selLen));
      const b = a + waveEditor.selLen;

      let x1 = (a/total)*W;
      let x2 = (b/total)*W;
      if (rev){
        x1 = ((total - b)/total)*W;
        x2 = ((total - a)/total)*W;
      }
      if (x2 < x1){ const t=x1; x1=x2; x2=t; }

      const px = clamp(e.clientX - rect.left, 0, W);

      // If user clicks outside the current selection, hide magnifier (it would feel "stuck on")
      // Selection may still jump/move, but magnifier should close until user interacts inside selection/handles again.

      // Resize hit zones:
      // Wave editor must feel the same as the Slice editor:
      // - only resize when you're truly near an edge
      // - the "move" area should NOT become a tiny strip
      const HANDLE_PX = 12; // how close (in pixels) to the selection edge counts as grabbing the edge
      const nearL = (Math.abs(px - x1) <= HANDLE_PX);
      const nearR = (Math.abs(px - x2) <= HANDLE_PX);
      const clickInSel = (px >= x1 && px <= x2);
      // If zoom window is currently visible, a click outside the selection should ONLY close zoom.
      // Do not let that same click reposition/jump the selection. (Second click can act normally.)
      const magVisible = !!(_mag && _mag.el && _mag.el.style.display !== 'none' && (_mag.srcTag === 'wave'));
      if (!clickInSel && !nearL && !nearR){
        if (magVisible){
          try{ magHide(); }catch(_){ }
          waveEditor.dragging = false;
          try{ waveBigEl.releasePointerCapture(e.pointerId); }catch(_){ }
          return;
        }
        try{ magHide(); }catch(_){ }
      }

      const hitSel = (px >= x1 && px <= x2);
      // IMPORTANT:
      // - Edge grabs must win over move.
      // - Like the Slice editor, clicking in the left/middle/right of the selection
      //   should pick L/M/R behavior (so drag + nudge behave intuitively).
      //
      // Previous versions used magEdgeFromClick(), but that made the middle region
      // effectively disappear for some selection widths. We guarantee a real middle zone.
      let clickEdge = "C";
      const selWpx = Math.max(0, x2 - x1);
      if (hitSel && !(nearL || nearR)) {
        // If selection is very small, don't try to do L/R by region; only true edge grabs resize.
        if (selWpx < (HANDLE_PX * 2 + 10)) {
          clickEdge = "C";
        } else {
          const leftCut  = x1 + selWpx / 3;
          const rightCut = x2 - selWpx / 3;
          if (px < leftCut) clickEdge = "L";
          else if (px > rightCut) clickEdge = "R";
          else clickEdge = "C";
        }
      }

      if (nearL || (hitSel && clickEdge==="L")) waveEditor.mode = "resizeL";
      else if (nearR || (hitSel && clickEdge==="R")) waveEditor.mode = "resizeR";
      else waveEditor.mode = "move";

      if (!hitSel && !(nearL || nearR)) { try{ magHide(); }catch(_){ } }

      
      
      // Auto magnifier on dense waveforms (click selection: L/M/R)
      try{
        const src = waveEditor.src;
        if (src && src.L){
          const Wm = waveBigEl.width|0;
          const total = src.L.length|0;
          const density = total / Math.max(1, Wm);
          const allowMag = true; // always allow magnifier in Wave Editor (also after Trim)
          if (allowMag){
            const stt = waveEditor.selStart|0;
            const enn = (waveEditor.selStart|0) + (waveEditor.selLen|0);
            const xSelL = (stt / Math.max(1,total)) * Wm;
            const xSelR = (enn / Math.max(1,total)) * Wm;

            let edge = "C";
            if (waveEditor.mode==="resizeL") edge = "L";
            else if (waveEditor.mode==="resizeR") edge = "R";
            else edge = clickEdge;

            try{ waveEditor.nudgeEdge = edge; }catch(_){ }

            if (hitSel || nearL || nearR){
            magShow({
              tag:"wave",
              src, total,
              selStart: stt,
              selEnd: enn,
              edge,
              centerPos: (edge==="C" ? Math.round((px / Math.max(1,Wm)) * total) : null),
              x: (magAnchorWave(total, stt, enn)?.x ?? e.clientX),
              y: e.clientY,
              label: (edge==="L"?"Resize L":(edge==="R"?"Resize R":"Move")) + "  (Esc: hide zoom)"
            });
            }
          }
        }
  }catch(_){}
waveEditor._px0 = px;
      waveEditor._start0 = a;
      waveEditor._len0 = waveEditor.selLen;

      // for move mode we keep the old dragDx behavior (grab anywhere inside selection)
      const t = px / W;
      const tt = rev ? (1 - t) : t;
      const srcAtPx = clamp(Math.round(tt * total), 0, total);
            waveEditor._grabSrcAtPx = srcAtPx;
      // anchors for grip resizing (important because grips sit slightly outside the selection)
      waveEditor._edgeL0 = waveEditor._start0|0;
      waveEditor._edgeR0 = (waveEditor._start0|0) + (waveEditor._len0|0);
      waveEditor.dragDx = clamp(srcAtPx - a, 0, waveEditor.selLen);

      const selW = (waveEditor.selLen/total)*W;
      if (waveEditor.mode === "move"){
        if (px < x1 || px > x1 + selW){
          waveEditor.dragDx = Math.round(waveEditor.selLen/2);
          wavePickFromX(e.clientX);
        } else {
          waveDragFromX(e.clientX);
        }
      } else {
        // immediate feedback on grab
        scheduleWaveDraw();
      }
    });

    waveBigEl.addEventListener("pointermove", (e)=>{
      if (!waveEditor.open || !waveEditor.dragging) return;

      if (waveEditor.mode === "move"){
        waveDragFromX(e.clientX);
        waveMagSync(e.clientX, e.clientY);
        return;
      }

      const rect = waveBigEl.getBoundingClientRect();
      const W = rect.width;
      const total = waveEditor.src.L.length;
      const rev = !!(state?.cells?.[waveEditor.col]?.[waveEditor.row]?.settings?.reverse);
      const px = clamp(e.clientX - rect.left, 0, W);

      const t = px / W;
      const tt = rev ? (1 - t) : t;
      const srcAtPx = clamp(Math.round(tt * total), 0, total);
      const dFrames = Math.round((px - waveEditor._px0) / W * total);

      const cellFrames = getCellFrames(waveEditor.row);
      const maxLen = Math.max(1, Math.min(cellFrames, total));

            let start = waveEditor._start0;
      let len   = waveEditor._len0;
      const end0 = waveEditor._start0 + waveEditor._len0;

      if (!rev){
        if (waveEditor.mode === "resizeR"){
          const dFrames = (srcAtPx - (waveEditor._grabSrcAtPx|0));
          let end = clamp((waveEditor._edgeR0|0) + dFrames, start + 1, total);
          let newLen = end - start;
          if (newLen > maxLen){
            // slide window when at max length (like split editor)
            const overflow = newLen - maxLen;
            start = clamp(start + overflow, 0, Math.max(0, total - maxLen));
            end = start + maxLen;
            newLen = maxLen;
          }
          // also clamp if near end
          if (start + newLen > total) newLen = Math.max(1, total - start);
          len = clamp(newLen, 1, Math.min(maxLen, total - start));
        } else { // resizeL
          start = clamp((waveEditor._edgeL0|0) + dFrames, 0, Math.max(0, end0 - 1));
          len = clamp(end0 - start, 1, Math.min(maxLen, total - start));
        }
      } else {
        if (waveEditor.mode === "resizeR"){
          // screen-right handle adjusts START (reverse)
          start = clamp((waveEditor._edgeL0|0) + (srcAtPx - (waveEditor._grabSrcAtPx|0)), 0, Math.max(0, end0 - 1));
          len = clamp(end0 - start, 1, Math.min(maxLen, total - start));
        } else { // resizeL: screen-left handle adjusts END (reverse)
          let end = clamp((waveEditor._edgeR0|0) + (srcAtPx - (waveEditor._grabSrcAtPx|0)), start + 1, total);
          let newLen = end - start;
          if (newLen > maxLen){
            const overflow = newLen - maxLen;
            start = clamp(start + overflow, 0, Math.max(0, total - maxLen));
            end = start + maxLen;
            newLen = maxLen;
          }
          if (start + newLen > total) newLen = Math.max(1, total - start);
          len = clamp(newLen, 1, Math.min(maxLen, total - start));
        }
      }


      waveEditor.selStart = start;
      waveEditor.selLen = len;
      commitWaveSelection();
      scheduleWaveDraw();
      waveMagSync(e.clientX, e.clientY);
    });

    waveBigEl.addEventListener("pointerup", (e)=>{
if (!waveEditor.open) return;
      waveEditor.dragging = false;
      try{ waveBigEl.releasePointerCapture(e.pointerId); }catch(_){}
    });

    window.addEventListener("keydown", (e)=>{
      if (!waveEditor.open) return;

      if (e.key === "Escape"){
        // Esc first hides the zoom window (magnifier) if it is visible; Esc again closes the editor.
        try{
          const magVisible = (typeof _mag !== 'undefined' && _mag && _mag.el && _mag.el.style.display !== 'none');
          if (magVisible){
            magHide();
            e.preventDefault();
            e.stopPropagation();
            if (e.stopImmediatePropagation) e.stopImmediatePropagation();
            return;
          }
        }catch(_){ }
        closeWaveEditor();
        return;
      }

      // Undo trim (Ctrl/Cmd+Z)
      if ((e.ctrlKey || e.metaKey) && (e.key === "z" || e.key === "Z")){
        e.preventDefault();
        e.stopPropagation();
        try{ waveEditorUndoTrim(); }catch(_e){}
        return;
      }

      // Space plays the current selection
      if (e.code === "Space" || e.key === " "){
        e.preventDefault();
        e.stopPropagation();
        
        // prevent focus ring from last-clicked buttons (e.g. Trim/Load)
        const _ae = document.activeElement;
        if (_ae && _ae.tagName === "BUTTON") _ae.blur();
try{
          const total = waveEditor.src.L.length;
          const start = clamp(waveEditor.selStart, 0, Math.max(0, total - waveEditor.selLen));
          const end = Math.min(total, start + waveEditor.selLen);

          const cell = getCell(waveEditor.col, waveEditor.row);
          const isRev = !!(cell && cell.settings && cell.settings.reverse);

          let L = waveEditor.src.L.subarray(start,end);
          let R = waveEditor.src.R.subarray(start,end);

          if (isRev){
            const n = end - start;
            const rL = new Float32Array(n);
            const rR = new Float32Array(n);
            for (let i=0, j=n-1; i<n; i++, j--){
              rL[i] = L[j];
              rR[i] = R[j];
            }
            L = rL; R = rR;
          }

          _playLR(L,R);
        }catch(err){
          showFatal(err);
        }
        return;
      }




      // L / M / R: force which part of the selection is controlled (like Split Editor)
      if (!e.ctrlKey && !e.metaKey && !e.altKey){
        const k = e.key;
        if (k==='l' || k==='L' || k==='m' || k==='M' || k==='r' || k==='R'){
          const edge = (k==='l' || k==='L') ? 'L' : ((k==='r' || k==='R') ? 'R' : 'C');
          waveEditor.nudgeEdge = edge;
          try{
            if (typeof _mag !== 'undefined' && _mag && _mag.el && _mag.el.style.display !== 'none'){
              _mag.edge = edge;
              // keep the zoom window in sync visually
              magRenderZIndicators();
              magRequestDraw();
            }
          }catch(_){ }
          e.preventDefault();
          e.stopPropagation();
          if (e.stopImmediatePropagation) e.stopImmediatePropagation();
          return;
        }
      }
      // Nudge selection (Arrow keys). Shift = coarse, Alt/Option = fine.
      if (e.key === "ArrowLeft" || e.key === "ArrowRight"){
        e.preventDefault();
        const dir = (e.key === "ArrowRight") ? 1 : -1;
        const fine = e.altKey ? 16 : 0;          // ~1.3ms at 48k
        const coarse = e.shiftKey ? 1024 : 0;     // ~42.7ms at 48k
        const base = 256;                         // ~5.3ms at 48k
        const step = fine || coarse || base;
        // If magnifier is open on the Wave editor, use its edge (L/R/C) to decide what nudges.
        const mode = ((_mag && _mag.on && (_mag.edge==='L' || _mag.edge==='R')) ? _mag.edge : (waveEditor.nudgeEdge||'C'));
        waveNudgeActive(dir * step, mode);
      }
    }, true);
  }
  const helpCloseBtnEl = document.getElementById("helpCloseBtn");  // Download modal elements are defined after this <script> block in the HTML.
  // So we query them lazily when needed (prevents null references).
  let dlModalItems = [];
const fileInput = document.getElementById("fileInput");
  const folderInput = document.getElementById("folderInput");
  const random64Btn = document.getElementById("random64Btn");

  const enableAudioBtn = document.getElementById("enableAudioBtn");
  const tempoModeEl = document.getElementById("tempoMode");
  const bpmEl = document.getElementById("bpm");
  const beatsPerCellEl = document.getElementById("beatsPerCell");
  const splitFitEl = document.getElementById("splitFit");
  const normalizeOnLoadEl = document.getElementById("normalizeOnLoad");
  const nameTemplateEl = document.getElementById("nameTemplate");

  // ====== Name template history (last 5) ======
  const nameTemplateHistoryEl = document.getElementById("nameTemplateDropMenu");
  const nameTemplateDropBtn = document.getElementById("nameTemplateDropBtn");
  const NAME_TEMPLATE_HISTORY_KEY = "tcm_name_template_history_v1";
  const NAME_TEMPLATE_HISTORY_MAX = 5;

  function loadNameTemplateHistory(){
    try{
      const raw = localStorage.getItem(NAME_TEMPLATE_HISTORY_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      if (!Array.isArray(arr)) return [];
      const seen = new Set();
      const out = [];
      for (const v of arr){
        const s = String(v || "").trim();
        if (!s) continue;
        if (seen.has(s)) continue;
        seen.add(s);
        out.push(s);
      }
      return out.slice(0, NAME_TEMPLATE_HISTORY_MAX);
    }catch{
      return [];
    }
  }

  function saveNameTemplateHistoryValue(value){
    const v = String(value || "").trim();
    if (!v) return;

    const cur = loadNameTemplateHistory();
    const next = [v, ...cur.filter(x => x !== v)].slice(0, NAME_TEMPLATE_HISTORY_MAX);

    try{ localStorage.setItem(NAME_TEMPLATE_HISTORY_KEY, JSON.stringify(next)); }catch{}
    renderNameTemplateHistory(next);
  }

  function renderNameTemplateHistory(list){
    if (!nameTemplateHistoryEl) return;
    const arr = Array.isArray(list) ? list : loadNameTemplateHistory();

    if (!arr.length){
      nameTemplateHistoryEl.innerHTML = '<div class="tplItem" style="opacity:.7; cursor:default;"><span class="tplTxt">No recent templates yet</span></div>';
      return;
    }

    nameTemplateHistoryEl.innerHTML = arr.map((t, i) => {
      const safe = String(t)
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;");
      const hint = i === 0 ? "default on start" : "pick";
      return `<div class="tplItem" role="option" data-value="${safe}"><span class="tplTxt">${safe}</span><span class="tplHint">${hint}</span></div>`;
    }).join("");
  }

function positionNameTemplateMenu(){
    if (!nameTemplateHistoryEl) return;
    const field = document.querySelector(".field.nameTpl");
    if (!field) return;
    const wrap = field.querySelector(".tplWrap") || field;
    const r = wrap.getBoundingClientRect();

    // menu width uses CSS width; compute actual after render
    // place below input, align right edge to input+button
    const margin = 6;
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);

    // temporarily show for measurement
    const wasOpen = nameTemplateHistoryEl.classList.contains("open");
    if (!wasOpen){
      nameTemplateHistoryEl.style.visibility = "hidden";
      nameTemplateHistoryEl.classList.add("open");
      positionNameTemplateMenu();
    }

    const mr = nameTemplateHistoryEl.getBoundingClientRect();
    const mw = mr.width || 320;

    if (!wasOpen){
      nameTemplateHistoryEl.classList.remove("open");
      nameTemplateHistoryEl.style.visibility = "";
    }

    let left = r.right - mw;
    left = Math.max(8, Math.min(left, vw - mw - 8));
    let top = r.bottom + margin;
    // keep within viewport
    if (top + mr.height > vh - 8){
      top = Math.max(8, r.top - mr.height - margin);
    }

    nameTemplateHistoryEl.style.left = left + "px";
    nameTemplateHistoryEl.style.top = top + "px";
  }


  function closeNameTemplateMenu(){
    if (!nameTemplateHistoryEl) return;
    nameTemplateHistoryEl.classList.remove("open");
    if (nameTemplateDropBtn) nameTemplateDropBtn.setAttribute("aria-expanded","false");
  }

  function toggleNameTemplateMenu(){
    if (!nameTemplateHistoryEl) return;
    const open = !nameTemplateHistoryEl.classList.contains("open");
    if (open){
      renderNameTemplateHistory(loadNameTemplateHistory());
      positionNameTemplateMenu();
      nameTemplateHistoryEl.classList.add("open");
      if (nameTemplateDropBtn) nameTemplateDropBtn.setAttribute("aria-expanded","true");
    } else {
      closeNameTemplateMenu();
    }
  }

  function initNameTemplateHistory(){
    const hist = loadNameTemplateHistory();

    // Show most recent immediately on start.
    if (hist.length){
      nameTemplateEl.value = hist[0];
    } else {
      // Seed history with default value so there is something to pick later.
      const def = String(nameTemplateEl.value || "").trim();
      if (def){
        try{ localStorage.setItem(NAME_TEMPLATE_HISTORY_KEY, JSON.stringify([def])); }catch{}
      }
    }
    renderNameTemplateHistory(loadNameTemplateHistory());

    // Save on blur / Enter (treat as "made")
    nameTemplateEl.addEventListener("blur", () => {
      saveNameTemplateHistoryValue(nameTemplateEl.value);
    });
    nameTemplateEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter"){
        e.preventDefault();
        saveNameTemplateHistoryValue(nameTemplateEl.value);
        nameTemplateEl.blur();
      }
      if (e.key === "Escape"){
        closeNameTemplateMenu();
      }
    });

    // Dropdown button: pick from static list (no typeahead)
    if (nameTemplateDropBtn){
      nameTemplateDropBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        toggleNameTemplateMenu();
      });
    }

    // Click an item: replace input value (no append), then bump to top
    if (nameTemplateHistoryEl){
      nameTemplateHistoryEl.addEventListener("click", (e) => {
        const item = e.target.closest(".tplItem[data-value]");
        if (!item) return;
        const v = String(item.dataset.value || "").trim();
        if (!v) return;
        nameTemplateEl.value = v;     // REPLACE (not append)
        saveNameTemplateHistoryValue(v);
        closeNameTemplateMenu();
        nameTemplateEl.focus();
        try{ nameTemplateEl.setSelectionRange(v.length, v.length); }catch{}
      });
    }

    // Reposition on resize/scroll
    window.addEventListener("resize", () => {
      if (nameTemplateHistoryEl && nameTemplateHistoryEl.classList.contains("open")) positionNameTemplateMenu();
    });
    window.addEventListener("scroll", () => {
      if (nameTemplateHistoryEl && nameTemplateHistoryEl.classList.contains("open")) closeNameTemplateMenu();
    }, true);

    // Close on outside click
    document.addEventListener("click", (e) => {
      if (!nameTemplateHistoryEl || !nameTemplateHistoryEl.classList.contains("open")) return;
      const within = e.target.closest(".field.nameTpl");
      if (!within) closeNameTemplateMenu();
    });
  }


  // +/- steppers for number inputs (supports both .numBtn and legacy .stepBtn)
  document.addEventListener("click", (e) => {
    // Newer overlay steppers
    const numBtn = e.target.closest(".numBtn");
    if (numBtn){
      const id = numBtn.dataset.target;
      const dir = numBtn.dataset.step; // "up" | "down"
      const el = document.getElementById(id);
      if (!el) return;
      try{
        if (dir === "up") el.stepUp();
        else el.stepDown();
      }catch(_){
        const step = Number(el.step || 1) || 1;
        const v = Number(el.value || 0) || 0;
        el.value = String(dir === "up" ? v + step : v - step);
      }
      el.dispatchEvent(new Event("input", {bubbles:true}));
      el.dispatchEvent(new Event("change", {bubbles:true}));
      return;
    }

    // Header BPM / Beats-per-cell steppers (HTML uses .stepBtn with data-for + data-dir)
    const stepBtn = e.target.closest(".stepBtn");
    if (!stepBtn) return;

    const id = stepBtn.dataset.for;
    const dir = Number(stepBtn.dataset.dir || 0); // -1 | +1
    const el = document.getElementById(id);
    if (!el) return;

    try{
      if (dir > 0) el.stepUp();
      else el.stepDown();
    }catch(_){
      const step = Number(el.step || 1) || 1;
      const v = Number(el.value || 0) || 0;
      el.value = String(dir > 0 ? v + step : v - step);
    }
    el.dispatchEvent(new Event("input", {bubbles:true}));
    el.dispatchEvent(new Event("change", {bubbles:true}));
  });
const exportAllBtn = document.getElementById("exportAllBtn");
  const helpBtn = document.getElementById("helpBtn");
  const stopBtn = document.getElementById("stopBtn");
  const clearAllBtn = document.getElementById("clearAllBtn");

  // Inspector controls
  const inspTitleEl = document.getElementById("inspTitle");
  const inspDescEl = document.getElementById("inspDesc");
  const inspPlayBtn = document.getElementById("inspPlayBtn");
  const inspLoadBtn = document.getElementById("inspLoadBtn");
  const inspClearBtn = document.getElementById("inspClearBtn");
  const inspNormalizeBtn = document.getElementById("inspNormalizeBtn");
  const inspCopyToColBtn = document.getElementById("inspCopyToColBtn");
  const inspCopyToAllBtn = document.getElementById("inspCopyToAllBtn");

  const volEl = document.getElementById("vol");
  const volValEl = document.getElementById("volVal");
  const fadeInEl = document.getElementById("fadeIn");
  const fadeInValEl = document.getElementById("fadeInVal");
  const fadeOutEl = document.getElementById("fadeOut");
  const fadeOutValEl = document.getElementById("fadeOutVal");
  const fitModeEl = document.getElementById("fitMode");
  const cellNameEl = document.getElementById("cellName");
  const fitValEl = document.getElementById("fitVal");
  const muteEl = document.getElementById("mute");
  const reverseEl = document.getElementById("reverse");
  const cellInfoEl = document.getElementById("cellInfo");

  // Perf step 3: inspector DOM diffing (avoid redundant DOM writes)
  let __inspCache = { selKey: null };

  // ====== Helpers ======
  function toast(msg, ms=4200){
    toastEl.textContent = msg;
    toastEl.classList.toggle("warn", /too long|te lang/i.test(msg));
    toastEl.classList.add("show");
    clearTimeout(toastEl._t);
    if (ms >= 999999){
      toastEl._t = null;
      return;
    }
    toastEl._t = setTimeout(() => toastEl.classList.remove("show"), ms);
  }

  // Status helper used by import/export flows
  function setStatus(msg, kind=""){
    const ms = kind === "bad" ? 999999 : (kind === "warn" ? 6500 : 2400);
    toast(msg, ms);
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function getDateStamp(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    return `${y}${m}${day}`;
  }

  function sanitizeFilename(s){
    const base = String(s || "").replace(/\s+/g,' ').trim();
    const safe = base.replace(/[^a-zA-Z0-9_\- .]+/g, "_").trim().replace(/\s+/g,'_');
    return safe.length ? safe.slice(0, 120) : "file";
  }

  function formatNameForCol(colIdx, colFrames){
    const t = String(nameTemplateEl.value || "matrix_col{col}_{date}");
    const mode = tempoModeEl.checked ? "tempo" : "fixed";
    const bpm = Number(bpmEl.value || 120);
    const colname = sanitizeFilename(state.colNames[colIdx] || `col${colIdx+1}`);
    const out = t
      .replaceAll("{col}", String(colIdx+1))
      .replaceAll("{colname}", colname)
      .replaceAll("{mode}", mode)
      .replaceAll("{bpm}", String(bpm))
      .replaceAll("{sr}", String(SR))
      .replaceAll("{frames}", String(colFrames))
      .replaceAll("{date}", getDateStamp());
    return sanitizeFilename(out) + ".wav";
  }

  function getAudioCtx(){
    if (!state.audioCtx){
      const Ctx = window.AudioContext || window.webkitAudioContext;
      state.audioCtx = new Ctx();
    }
    return state.audioCtx;
  }

  async function ensureAudio(){
    const ctx = getAudioCtx();
    if (ctx.state !== "running"){
      await ctx.resume();
    }
  }

  function stopPlayback(){
    if (state.currentSrc){
      try { state.currentSrc.stop(); } catch {}
      try { state.currentSrc.disconnect(); } catch {}
      state.currentSrc = null;
    }
    if (state.currentCellEl){
      state.currentCellEl.classList.remove("playing");
      state.currentCellEl = null;
    }
  }

  function getCellFramesArray(){
    // Drift-free quantization in tempo mode:
    // Compute total frames for 8 cells once, round once, then distribute the remainder.
    if (!tempoModeEl.checked){
      return new Array(ROWS).fill(FIXED_CELL_FRAMES);
    }

    const bpm = clamp(Number(bpmEl.value || 120), 1, 10000);
    const beatsPerCell = clamp(Number(beatsPerCellEl.value || 1), 0.0001, 10000);
    const secPerCell = (beatsPerCell * 60) / bpm;

    const totalFrames = Math.max(1, Math.round(secPerCell * SR * ROWS));
    const base = Math.floor(totalFrames / ROWS);
    const rem = totalFrames - base * ROWS;

    const arr = new Array(ROWS);
    for (let i=0;i<ROWS;i++){
      arr[i] = base + (i < rem ? 1 : 0);
    }
    return arr;
  }

  function getCellFrames(row){
    const a = getCellFramesArray();
    const r = clamp((row == null ? 0 : row) | 0, 0, ROWS-1);
    return a[r];
  }

  function getColFrames(){
    const a = getCellFramesArray();
    let sum = 0;
    for (let i=0;i<a.length;i++) sum += a[i];
    return sum;
  }

  function seconds(frames){ return frames / SR; }

  function lerp(a,b,t){ return a + (b-a)*t; }

  function resampleToLength(src, outLen){
    const inLen = src.length;
    const out = new Float32Array(outLen);
    if (outLen === 1){
      out[0] = src.length ? src[0] : 0;
      return out;
    }
    if (inLen === 0){
      return out;
    }
    if (inLen === 1){
      out.fill(src[0]);
      return out;
    }
    const scale = (inLen - 1) / (outLen - 1);
    for (let i=0;i<outLen;i++){
      const pos = i * scale;
      const idx = Math.floor(pos);
      const frac = pos - idx;
      const a = src[idx];
      const b = src[Math.min(inLen-1, idx+1)];
      out[i] = lerp(a,b,frac);
    }
    return out;
  }

  function resampleRate(src, srcRate, dstRate){
    if (srcRate === dstRate) return new Float32Array(src); // copy
    const ratio = dstRate / srcRate;
    const outLen = Math.max(1, Math.round(src.length * ratio));
    if (outLen === 1){
      return new Float32Array([src.length ? src[0] : 0]);
    }
    const out = new Float32Array(outLen);
    const scale = (src.length - 1) / (outLen - 1);
    for (let i=0;i<outLen;i++){
      const pos = i * scale;
      const idx = Math.floor(pos);
      const frac = pos - idx;
      const a = src[idx];
      const b = src[Math.min(src.length-1, idx+1)];
      out[i] = lerp(a,b,frac);
    }
    return out;
  }

  function computePeaks(left, right, points=72){
    if (!left || !right) return null;
    const n = left.length;
    if (n === 0) return new Float32Array(points);

    const peaks = new Float32Array(points);
    const step = Math.max(1, Math.floor(n / points));

    for (let p=0; p<points; p++){
      const start = p * step;
      const end = Math.min(n, start + step);
      let mx = 0;
      for (let i=start;i<end;i++){
        const a = Math.abs(left[i]);
        const b = Math.abs(right[i]);
        const m = Math.max(a,b);
        if (m > mx) mx = m;
      }
      peaks[p] = mx;
    }
    return peaks;
  }

  function drawWave(canvas, peaks, settings=null, targetFrames=0, reverse=false, selStartFrames=null, selLenFrames=null, totalFrames=null){
    const ctx = canvas.getContext("2d");
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    // center line
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, h/2);
    ctx.lineTo(w, h/2);
    ctx.stroke();

    // selection mapping (when drawing full source with a selection window)
    const hasSel = (selStartFrames != null && selLenFrames != null && totalFrames != null && totalFrames > 0 && totalFrames > selLenFrames);
    const selStart = hasSel ? clamp(selStartFrames, 0, Math.max(0, totalFrames - selLenFrames)) : 0;
    const selLen = hasSel ? selLenFrames : 0;
    const _selPx1 = hasSel ? Math.floor((selStart / totalFrames) * w) : 0;
    const _selPx2 = hasSel ? Math.max(_selPx1+2, Math.floor(((selStart + selLen) / totalFrames) * w)) : 0;
    const selW  = hasSel ? Math.max(2, _selPx2 - _selPx1) : 0;

    // If rendering reversed, mirror selection window so it stays aligned with audio playback.
    // Selection is stored in source-frame coordinates (start from 0 at source start).
    // When waveform is drawn reversed, left side represents the end of the source.
    let __selPx1 = _selPx1, __selPx2 = _selPx2;
    if (hasSel && reverse){
      __selPx1 = w - _selPx2;
      __selPx2 = w - _selPx1;
    }


    if (!peaks){
      ctx.fillStyle = "rgba(155,176,203,0.55)";
      ctx.font = "11px " + getComputedStyle(document.documentElement).getPropertyValue('--mono');
      ctx.fillText("empty", 8, 16);
      return;
    }

    const mid = h/2;
    const usable = (h/2 - 3);

    const n = peaks.length;
    const g0 = settings ? Number(settings.gain || 1) : 1;
    const mute = settings ? !!settings.mute : false;
    const gain = mute ? 0 : Math.max(0, Math.min(2, g0));
    const baseGain = mute ? 0 : 1;

    // fade frames (cap at half length so in/out can't overlap weirdly)
    let fi = 0, fo = 0;
    if (settings && targetFrames > 0){
      fi = Math.round((Number(settings.fadeInMs || 0)/1000) * SR);
      fo = Math.round((Number(settings.fadeOutMs || 0)/1000) * SR);
      const half = Math.floor(targetFrames / 2);
      fi = Math.max(0, Math.min(fi, half));
      fo = Math.max(0, Math.min(fo, half));
    }

    // helper: envelope at normalized time t (0..1)
    function envAtT(t){
      if (!settings || targetFrames <= 0) return gain;
      const frame = t * (targetFrames - 1);
      let env = 1;
      if (fi > 0 && frame < fi) env = frame / fi;
      if (fo > 0 && frame > (targetFrames - fo)) env = (targetFrames - frame) / fo;
      env = Math.max(0, Math.min(1, env));
      return env * gain;
    }

    // fade region shading (visual cue)
    // When showing full source, fades are relative to the selection window (cell length).
    if (settings && targetFrames > 0 && (fi > 0 || fo > 0)){
      ctx.fillStyle = "rgba(125,211,252,0.10)";
      const baseX = hasSel ? __selPx1 : 0;
      const baseW = hasSel ? selW   : w;

      if (fi > 0){
        const xw = (fi / targetFrames) * baseW;
        ctx.fillRect(baseX, 0, xw, h);
      }
      if (fo > 0){
        const xw = (fo / targetFrames) * baseW;
        ctx.fillRect(baseX + baseW - xw, 0, xw, h);
      }

      // boundary ticks
      ctx.strokeStyle = "rgba(125,211,252,0.55)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      if (fi > 0){
        const x = baseX + (fi / targetFrames) * baseW;
        ctx.moveTo(x+0.5, 2); ctx.lineTo(x+0.5, h-2);
      }
      if (fo > 0){
        const x = baseX + baseW - (fo / targetFrames) * baseW;
        ctx.moveTo(x+0.5, 2); ctx.lineTo(x+0.5, h-2);
      }
      ctx.stroke();
    }

    // waveform peaks, scaled by gain + fades
    ctx.strokeStyle = "rgba(122,167,255,0.85)";
    ctx.lineWidth = 1;

    for (let i=0;i<n;i++){
      const p = reverse ? peaks[n-1-i] : peaks[i];
      const t = (i + 0.5) / n;            // output time (not reversed)
      const e = (hasSel ? baseGain : envAtT(t));                // 0..2
      const amp = Math.min(1, p * e);     // clip for display (keeps it readable)
      const x = (i + 0.5) * (w / n);
      const y = amp * usable;
      ctx.beginPath();
      ctx.moveTo(x, mid - y);
      ctx.lineTo(x, mid + y);
      ctx.stroke();

    // === selection result overlay (what the cell actually plays) ===
    if (hasSel){
      ctx.strokeStyle = "rgba(147,197,253,0.9)";
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      let first = true;

      for (let x = __selPx1; x <= __selPx2; x++){
        const idx = Math.floor((x / w) * peaks.length);
        const p = peaks[idx] || 0;

        const tl = (selW <= 1) ? 0 : ((x - __selPx1) / (selW - 1));
        const env = envAtT(tl);
        const amp = p * env;

        const y = mid - amp * usable;
        if (first){
          ctx.moveTo(x + 0.5, y);
          first = false;
        }else{
          ctx.lineTo(x + 0.5, y);
        }
      }
      ctx.stroke();
    }
    }

    // envelope line (shows gain + fades in realtime)
    if (settings){
      ctx.strokeStyle = "rgba(52,211,153,0.85)";
      ctx.lineWidth = 1;

      const baseX = hasSel ? __selPx1 : 0;
      const baseW = hasSel ? selW   : w;

      // top envelope
      ctx.beginPath();
      for (let i=0; i<baseW; i++){
        const t = (baseW <= 1) ? 0 : (i / (baseW - 1));
        const e = Math.min(1, envAtT(t));
        const y = e * usable;
        const x = baseX + i;
        if (i === 0) ctx.moveTo(x + 0.5, mid - y);
        else ctx.lineTo(x + 0.5, mid - y);
      }
      ctx.stroke();

      // bottom envelope
      ctx.beginPath();
      for (let i=0; i<baseW; i++){
        const t = (baseW <= 1) ? 0 : (i / (baseW - 1));
        const e = Math.min(1, envAtT(t));
        const y = e * usable;
        const x = baseX + i;
        if (i === 0) ctx.moveTo(x + 0.5, mid + y);
        else ctx.lineTo(x + 0.5, mid + y);
      }
      ctx.stroke();
    }

// Selection overlay (full-source view)
    if (selStartFrames != null && selLenFrames != null && totalFrames != null && totalFrames > 0 && totalFrames > selLenFrames){
      const a = clamp(selStartFrames, 0, Math.max(0, totalFrames - selLenFrames));
      const b = a + selLenFrames;
      const x1 = Math.floor((a / totalFrames) * w);
      const x2 = Math.max(x1+2, Math.floor((b / totalFrames) * w));

      // Mirror selection overlay when drawing reversed (mini-wave + editor should match)
      let xx1 = x1, xx2 = x2;
      if (reverse){
        xx1 = Math.max(0, w - x2);
        xx2 = Math.min(w, w - x1);
      }

      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.fillRect(xx1, 0, xx2-xx1, h);
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 2;
      ctx.strokeRect(xx1+1, 1, Math.max(0, xx2-xx1-2), h-2);
    }
  }

  // ====== Performance: visible-only waveform redraw ======
  const _waveVis = new WeakMap();     // canvas -> bool
  const _waveDirty = new WeakMap();   // canvas -> bool
  const _waveMeta = new WeakMap();    // canvas -> {col,row}
  let _waveObserver = null;
  let _waveRAF = 0;
  const _waveQueue = new Set();

  function setupWaveObserver(){
    // Fallback: if IntersectionObserver is unavailable, just draw everything.
    if (!('IntersectionObserver' in window)){
      document.querySelectorAll('canvas.wave').forEach(cv => {
        _waveVis.set(cv, true);
        _waveDirty.set(cv, true);
        const col = Number(cv.dataset.col);
        const row = Number(cv.dataset.row);
        _waveMeta.set(cv, { col, row });
        _waveQueue.add(cv);
      });
      scheduleWaveFlush();
      return;
    }

    try{ if (_waveObserver) _waveObserver.disconnect(); }catch{}
    _waveObserver = new IntersectionObserver((entries) => {
      for (const e of entries){
        const cv = e.target;
        const vis = !!(e.isIntersecting && e.intersectionRatio > 0);
        _waveVis.set(cv, vis);
        if (vis && _waveDirty.get(cv)){
          _waveQueue.add(cv);
        }
      }
      scheduleWaveFlush();
    }, { root: null, threshold: [0, 0.01, 0.1] });

    document.querySelectorAll("canvas.wave").forEach(cv => {
      const col = Number(cv.dataset.col);
      const row = Number(cv.dataset.row);
      _waveMeta.set(cv, { col, row });
      _waveVis.set(cv, false);
      _waveDirty.set(cv, true); // initial draw
      _waveObserver.observe(cv);
    });

    // Draw whatever is already visible
    markAllWavesDirty();
  }

  
  function hardResetEngines(){
    // Attempt to drop CPU/memory pressure on Safari/Firefox by stopping any pending RAF loops
    try{ if (__waveDrawPending) { /* flag only */ __waveDrawPending = false; } }catch(e){}
    try{ if (_waveRAF) cancelAnimationFrame(_waveRAF); }catch(e){}
    _waveRAF = 0;
    try{ if (splitRAF) cancelAnimationFrame(splitRAF); }catch(e){}
    splitRAF = 0;
    try{ if (_mag && _mag._raf) cancelAnimationFrame(_mag._raf); }catch(e){}
    if (_mag){ _mag._raf = 0; _mag.on = false; }

    // Drop wave queues / maps to release references
    try{ _waveQueue && _waveQueue.clear(); }catch(e){}
    try{ _waveDirty = new WeakMap(); }catch(e){}
    try{ _waveMeta = new WeakMap(); }catch(e){}

    // Stop playback + fully reset AudioContext (Safari tends to retain buffers until context is closed)
    try{ stopPlayback(); }catch(e){}
    try{
      if (state && state.audioCtx){
        const ctx = state.audioCtx;
        state.audioCtx = null;
        // close is async; fire and forget
        Promise.resolve(ctx.close && ctx.close()).catch(()=>{});
      }
    }catch(e){}
    state.currentSrc = null;
    state.currentCellEl = null;
  }
function scheduleWaveFlush(){
    if (_waveRAF) return;
    _waveRAF = requestAnimationFrame(() => {
      _waveRAF = 0;
      _waveQueue.forEach(cv => {
        _waveQueue.delete(cv);
        if (!_waveDirty.get(cv)) return;

        const meta = _waveMeta.get(cv);
        if (!meta) return;

        _waveDirty.set(cv, false);
        const cell = state.cells[meta.col][meta.row];

        if (!cell || !cell.peaks){
          const ctx = cv.getContext("2d");
          ctx.clearRect(0,0,cv.width,cv.height);
          return;
        }

        {
        // If Apply created a trimmed cell buffer, show THAT in the mini-wave (requested UX)
        if (cell.viewTrimmed && cell.left && cell.left.length){
          const w = cv.width;
          if (!cell._trimPeaksByW) cell._trimPeaksByW = new Map();
          let peaks = cell._trimPeaksByW.get(w);
          if (!peaks){
            peaks = computePeaks(cell.left, w);
            cell._trimPeaksByW.set(w, peaks);
          }
          const total = cell.left.length;
          const selStart = (cell.selStartFrames != null) ? Math.round(cell.selStartFrames) : 0;
          const selLen = (cell.selLenFrames != null) ? Math.round(cell.selLenFrames) : total;
          drawWave(cv, peaks, cell.settings, total, !!cell.settings.reverse, selStart, selLen, total);
        }else{
          // Otherwise: if we have a full source, show that waveform with the selection window overlay.
          const key = cell.sourceKey || (cell.origin && cell.origin.split && cell.origin.split.sourceKey) || "";
          if (key && sourceStore.has(key)){
            const src = sourceStore.get(key);
            const peaks = getSourcePeaks(src, cv.width);
            const selStart = (Number.isFinite(cell.trimStartSrcFrames))
              ? Math.round(cell.trimStartSrcFrames)
              : ((cell.selStartFrames != null) ? cell.selStartFrames : 0);
            const selLen = (Number.isFinite(cell.trimLenSrcFrames) && cell.trimLenSrcFrames > 0)
              ? Math.round(cell.trimLenSrcFrames)
              : ((cell.selLenFrames != null) ? cell.selLenFrames : getCellFrames(meta.row));
            drawWave(cv, peaks, cell.settings, getCellFrames(meta.row), !!cell.settings.reverse, selStart, selLen, src.L.length);
          }else{
            drawWave(cv, cell.peaks, cell.settings, getCellFrames(meta.row), !!cell.settings.reverse);
          }
        }
        }
      });
    });
  }

  function markWaveDirty(col, row){
    const dom = (__cellDom[col] && __cellDom[col][row]) ? __cellDom[col][row] : null;
    const cv = dom ? dom.wave : document.getElementById(`wave-${col}-${row}`);
    if (!cv) return;
    _waveDirty.set(cv, true);
    if (_waveVis.get(cv)){
      _waveQueue.add(cv);
      scheduleWaveFlush();
    }
  }

  function markAllWavesDirty(){
    document.querySelectorAll("canvas.wave").forEach(cv => {
      _waveDirty.set(cv, true);
      if (_waveVis.get(cv)){
        _waveQueue.add(cv);
      }
    });
    scheduleWaveFlush();
  }

  function reverseInPlace(arr){
    for (let i=0, j=arr.length-1; i<j; i++, j--){
      const t = arr[i]; arr[i]=arr[j]; arr[j]=t;
    }
  }

  function applyFadesAndGain(L, R, settings, targetFrames){
    const gain = settings.gain;
    const mute = settings.mute;

    if (mute){
      L.fill(0); R.fill(0);
      return;
    }

    let fi = Math.round((settings.fadeInMs/1000) * SR);
    let fo = Math.round((settings.fadeOutMs/1000) * SR);

    // clamp to half length
    const half = Math.floor(targetFrames/2);
    fi = clamp(fi, 0, half);
    fo = clamp(fo, 0, half);

    // apply envelope + gain
    for (let i=0; i<targetFrames; i++){
      let env = 1.0;

      if (fi > 0 && i < fi){
        env *= (i / fi);
      }
      if (fo > 0 && i >= targetFrames - fo){
        env *= ((targetFrames - i) / fo);
      }

      const g = env * gain;
      L[i] *= g;
      R[i] *= g;
    }
  
    // Always apply a tiny safety fade to avoid clicks (in addition to user fades)
    const microFrames = Math.min(Math.floor(SR * 0.003), Math.floor(targetFrames/2)); // 3ms
    if (microFrames > 0){
      for (let i=0; i<microFrames; i++){
        const g = i / microFrames;
        L[i] *= g; R[i] *= g;
      }
      for (let i=0; i<microFrames; i++){
        const idx = targetFrames - 1 - i;
        const g = i / microFrames;
        const gg = 1 - g;
        L[idx] *= gg; R[idx] *= gg;
      }
    }

}

  function renderCellToTarget(cell, targetFrames){
    const s = cell.settings;
    const cacheKey = [
      targetFrames, s.fitMode, s.reverse, s.mute,
      s.gain.toFixed(4), Math.round(s.fadeInMs), Math.round(s.fadeOutMs),
      cell.left ? cell.left.length : 0,
      (typeof cell.selStartFrames === "number") ? cell.selStartFrames : 0,
      (typeof cell.selLenFrames === "number") ? cell.selLenFrames : 0
    ].join("|");

    if (cell.cache.key === cacheKey && cell.cache.L && cell.cache.R && cell.cache.frames === targetFrames){
      return { L: cell.cache.L, R: cell.cache.R };
    }

    const Lout = new Float32Array(targetFrames);
    const Rout = new Float32Array(targetFrames);

    if (!cell.left || !cell.right){
      // silence
      cell.cache = { key: cacheKey, L: Lout, R: Rout, frames: targetFrames };
      return { L: Lout, R: Rout };
    }

    let Lin = cell.left;
    let Rin = cell.right;

    // If selection metadata exists and the cell buffers still hold the full source,
    // render/preview/export from the selection window so fades happen at the selection edges.
    try{
      const key = (cell.editorKey && sourceStore.has(cell.editorKey)) ? cell.editorKey : (cell.sourceKey || "");
      const hasSel = (typeof cell.selStartFrames === "number") && (typeof cell.selLenFrames === "number");
      if (key && hasSel && sourceStore && sourceStore.has(key)){
        const src = sourceStore.get(key);
        const srcLen = src && src.L ? src.L.length : 0;
        if (srcLen > 0 && Lin.length === srcLen && cell.selLenFrames > 0 && srcLen > cell.selLenFrames){
          const selLen = clamp(cell.selLenFrames, 1, srcLen);
          const selStart = clamp(cell.selStartFrames, 0, Math.max(0, srcLen - selLen));
          Lin = Lin.subarray(selStart, selStart + selLen);
          Rin = Rin.subarray(selStart, selStart + selLen);
        }
      }
    }catch(_){}

    if (s.fitMode === "padtrim"){
      const n = Math.min(targetFrames, Lin.length);
      Lout.set(Lin.subarray(0,n), 0);
      Rout.set(Rin.subarray(0,n), 0);
    } else if (s.fitMode === "loop"){ // legacy: treat old "loop" as pad/trim
      const n = Math.min(targetFrames, Lin.length);
      Lout.set(Lin.subarray(0,n), 0);
      Rout.set(Rin.subarray(0,n), 0);
    } else { // "rate"
      // time-fit by resampling to exact targetFrames (pitch changes)
      const Lr = resampleToLength(Lin, targetFrames);
      const Rr = resampleToLength(Rin, targetFrames);
      Lout.set(Lr);
      Rout.set(Rr);
    }

    if (s.reverse){
      reverseInPlace(Lout);
      reverseInPlace(Rout);
    }

    applyFadesAndGain(Lout, Rout, s, targetFrames);

    cell.cache = { key: cacheKey, L: Lout, R: Rout, frames: targetFrames };
    return { L: Lout, R: Rout };
  }

  function measurePeakStereo(L, R){
    let peak = 0;
    for (let i=0;i<L.length;i++){
      const a = Math.abs(L[i]);
      const b = Math.abs(R[i]);
      if (a > peak) peak = a;
      if (b > peak) peak = b;
    }
    return peak;
  }

  function normalizeCellGain(cell){
    if (!cell.left || !cell.right){
      cell.settings.gain = 1.0;
      return;
    }
    const peak = measurePeakStereo(cell.left, cell.right);
    if (peak > 0){
      cell.settings.gain = clamp(1/peak, 0, 2);
    } else {
      cell.settings.gain = 1.0;
    }
  }

  // ====== Decode + load ======
  async function decodeFileToStereo48k(file){
    const ctx = getAudioCtx();
    const buf = await file.arrayBuffer();
    const decoded = await ctx.decodeAudioData(buf.slice(0));

    const srcRate = decoded.sampleRate;
    const chs = decoded.numberOfChannels;

    const ch0 = decoded.getChannelData(0);
    const ch1 = chs > 1 ? decoded.getChannelData(1) : decoded.getChannelData(0);

    const L = resampleRate(ch0, srcRate, SR);
    const R = resampleRate(ch1, srcRate, SR);

    return { left: L, right: R, name: file.name || "" };
  }

  async function loadFileIntoCell(col, row, file, opts={}){
    const silent = !!opts.silent;
    const cell = state.cells[col][row];
    cell.cache = { key:"", L:null, R:null, frames:0 };

    const {left, right, name} = await decodeFileToStereo48k(file);
    const _srcKey = getSourceKeyFromFile(file, name);
    ensureSourceInStore(_srcKey, left, right, name);
    cell.sourceKey = _srcKey;

    // Preserve imported selection metadata if present
    if (typeof cell.selStartFrames !== "number") cell.selStartFrames = 0;
    if (typeof cell.selLenFrames !== "number") cell.selLenFrames = Math.max(1, getCellFrames(row));

    // If a selection start was imported, apply it immediately to the cell audio (so playback/export matches)
    if (cell.selStartFrames > 0 || (cell.selLenFrames && cell.selLenFrames !== left.length)){
      const total = left.length;
      const selLen = clamp(cell.selLenFrames, 1, total);
      const start = clamp(cell.selStartFrames, 0, Math.max(0, total - selLen));
      const end = Math.min(total, start + selLen);
      // slice decoded full source into cell buffers
      const L = left.subarray(start, end);
      const R = right.subarray(start, end);
      cell.left = new Float32Array(L);
      cell.right = new Float32Array(R);
      cell.name = (name || "sample") + " · sel " + fmtTime(start);
      // ensure UI uses selection overlay
      cell.selStartFrames = start;
      cell.selLenFrames = selLen;
    }

    if (!cell.left){
      cell.left = left;
      cell.right = right;
    }
    cell.name = name;
    // Track origin for preset relinking
    cell.origin = {
      type: "file",
      fileName: (file && file.name) ? file.name : name,
      relPath: (file && (file.webkitRelativePath || file._relPath)) ? (file.webkitRelativePath || file._relPath) : "",
    };

    if (normalizeOnLoadEl.checked){
      normalizeCellGain(cell);
    }

    cell.peaks = computePeaks(cell.left, cell.right, MINI_PEAKS_POINTS);

    updateCellUI(col,row);
    updateColUI(col);

    if (!silent) toast(`Loaded cell: column ${col+1} / row ${row+1}`);
  }

  async function loadFileSplitIntoColumn(col, file){
    // Decode to 48k first
    const {left, right, name} = await decodeFileToStereo48k(file);
    const _srcKey = getSourceKeyFromFile(file, name);
    ensureSourceInStore(_srcKey, left, right, name);


    const colFrames = getColFrames();
    const cellFrames = getCellFrames(state.selected.row);

    // Create a column buffer by either pad/trim (default) or "rate fit"
    let colL, colR;
    if (splitFitEl.checked){
      colL = resampleToLength(left, colFrames);
      colR = resampleToLength(right, colFrames);
    } else {
      colL = new Float32Array(colFrames);
      colR = new Float32Array(colFrames);
      const n = Math.min(colFrames, left.length);
      colL.set(left.subarray(0,n), 0);
      colR.set(right.subarray(0,n), 0);
    }

    // Split into 8 slices => each becomes the cell's source (exact cellFrames)
    for (let r=0;r<ROWS;r++){
      const cell = state.cells[col][r];
      cell.sourceKey = _srcKey;
      cell.selLenFrames = Math.max(1, cellFrames);
      cell.selStartFrames = Math.max(0, Math.min((r*cellFrames), Math.max(0, left.length - cellFrames)));

      cell.cache = { key:"", L:null, R:null, frames:0 };
      cell.left = colL.subarray(r*cellFrames, (r+1)*cellFrames);
      cell.right = colR.subarray(r*cellFrames, (r+1)*cellFrames);
      cell.name = `${name} · ${getCellDisplayName(col, r)}`;
      cell.origin = {
        type: "split",
        fileName: (file && file.name) ? file.name : name,
        relPath: (file && (file.webkitRelativePath || file._relPath)) ? (file.webkitRelativePath || file._relPath) : "",
        sliceIndex: r,
        slices: 8,
        split: { sourceKey: _srcKey, startFrames: selStart, lenFrames: selLen, col, row: r }
      };

      // default: since slice is exact, pad/trim doesn't matter, but keep user's choice
      if (normalizeOnLoadEl.checked){
        normalizeCellGain(cell);
      }
      cell.peaks = computePeaks(cell.left, cell.right, MINI_PEAKS_POINTS);
      updateCellUI(col,r);
    }

    updateColUI(col);
    toast(`Load+Slice: column ${col+1}`);
  }


  // Import helper: restore per-cell slice windows from preset (instead of default 1/8 splits)
  async function loadFileSliceIntoColumnFromPreset(col, file, presetCells){
    // Decode to 48k first
    const {left, right, name} = await decodeFileToStereo48k(file);
    const _srcKey = getSourceKeyFromFile(file, name);
    ensureSourceInStore(_srcKey, left, right, name);

    const srcLen = left.length;

    for (let r=0;r<ROWS;r++){
      const cell = state.cells[col][r];
      const p = (Array.isArray(presetCells) && presetCells[r]) ? presetCells[r] : null;

      // Selection window (on original source frames)
      let selLen = (p && typeof p.selLenFrames === "number") ? Math.floor(p.selLenFrames) : Math.max(1, Math.floor(srcLen / ROWS));
      selLen = clamp(selLen, 1, Math.max(1, srcLen));

      let selStart = (p && typeof p.selStartFrames === "number") ? Math.floor(p.selStartFrames) : (r * selLen);
      selStart = clamp(selStart, 0, Math.max(0, srcLen - selLen));

      cell.sourceKey = _srcKey;
      cell.selStartFrames = selStart;
      cell.selLenFrames = selLen;

      // Remember slice window on ORIGINAL source for Wave Editor + preset roundtrip
      cell.trimStartSrcFrames = selStart;
      cell.trimLenSrcFrames   = selLen;

      // Store the slice audio in the cell (so mini-wave shows the slice, not the full source)
      const end = Math.min(srcLen, selStart + selLen);
      cell.cache = { key:"", L:null, R:null, frames:0 };
      cell.left  = new Float32Array(left.subarray(selStart, end));
      cell.right = new Float32Array(right.subarray(selStart, end));

      // This cell owns its slice buffers; keep full source reference in origin.split.sourceKey
      cell.sourceKey = null;

      cell.name = `${name} · ${getCellDisplayName(col, r)}`;
      cell.origin = {
        type: "split",
        fileName: (file && file.name) ? file.name : name,
        relPath: (file && (file.webkitRelativePath || file._relPath)) ? (file.webkitRelativePath || file._relPath) : "",
        sliceIndex: r,
        slices: 8,
        split: { sourceKey: _srcKey, startFrames: selStart, lenFrames: selLen, col, row: r }
      };

      if (normalizeOnLoadEl.checked){
        normalizeCellGain(cell);
      }

      cell.peaks = computePeaks(cell.left, cell.right, MINI_PEAKS_POINTS);
      updateCellUI(col, r);
    }

    updateColUI(col);
  }





// ====== Random fill (64 cells) from folder / multi-file selection ======
function getFileNameLower(file){
  const n = (file && (file.webkitRelativePath || file.name)) ? (file.webkitRelativePath || file.name) : "";
  return String(n || "").trim().toLowerCase();
}

function isAudioFile(file){
  if (!file) return false;
  if (file.type && file.type.startsWith('audio/')) return true;
  const n = getFileNameLower(file);
  const ext = (n.split('.').pop() || '').trim().toLowerCase();
  return ['wav','mp3','ogg','flac','aif','aiff','m4a','aac','opus','wma'].includes(ext);
}


  // ====== Random 64: fast duration probe (metadata only) ======
  const _tcmDurCache = new WeakMap(); // File -> seconds (number) or null
  async function getFileDurationSec(file){
    if (!file) return null;
    if (_tcmDurCache.has(file)) return _tcmDurCache.get(file);
    const dur = await new Promise((resolve) => {
      let url = "";
      let a = null;
      try{
        url = URL.createObjectURL(file);
        a = new Audio();
        a.preload = "metadata";
        const cleanup = () => {
          try{ if (a) { a.src = ""; a.load(); } }catch(_){}
          try{ if (url) URL.revokeObjectURL(url); }catch(_){}
        };
        a.onloadedmetadata = () => {
          const d = Number(a.duration);
          cleanup();
          resolve(Number.isFinite(d) ? d : null);
        };
        a.onerror = () => { cleanup(); resolve(null); };
        a.src = url;
      }catch(_){
        try{ if (url) URL.revokeObjectURL(url); }catch(__){}
        resolve(null);
      }
    });
    _tcmDurCache.set(file, dur);
    return dur;
  }

function shuffleInPlace(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = (Math.random() * (i + 1)) | 0;
    const t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
  }
  return arr;
}

async function randomFillFromFiles(files){
  const pool = Array.from(files || []).filter(isAudioFile);
  if (!pool.length){
    toast('No audio files found in selection.', 2600);
    return;
  }

  const cellTargets = [];
  for (let c=0;c<COLS;c++) for (let r=0;r<ROWS;r++) cellTargets.push({c,r});
  shuffleInPlace(cellTargets);

  let chosen = [];
  if (pool.length >= COLS*ROWS){
    // unique (no repeats)
    chosen = shuffleInPlace(pool.slice()).slice(0, COLS*ROWS);
  } else {
    // with replacement
    for (let i=0;i<COLS*ROWS;i++){
      chosen.push(pool[(Math.random()*pool.length)|0]);
    }
    toast(`Only ${pool.length} file(s) available — filling 64 cells with repeats.`, 2600);
  }

  toast(`Random fill: loading 64 cells from ${pool.length} file(s)...`, 1800);

  // Load sequentially (stable, avoids killing the browser)
  for (let i=0;i<cellTargets.length;i++){
    const {c,r} = cellTargets[i];
    await loadFileIntoCell(c, r, chosen[i], { silent: true });
    if (i === 31) toast('Random fill: halfway (32/64)...', 1300);
  }

  updateAllUI();
  toast('Random fill complete.', 2200);
}
async function loadFilesIntoColumnCells(col, files){
  const list = Array.from(files || []).filter(Boolean);
  if (!list.length) return;

  const max = Math.min(ROWS, list.length);

  toast(`Loading ${max} sample(s) → column ${col+1}...`, 1400);

  for (let r=0; r<max; r++){
    await loadFileIntoCell(col, r, list[r], { silent: true });
  }

  updateColUI(col);
  if (state.selected.has && state.selected.col === col){
    updateInspector();
  }

  if (list.length > ROWS){
    toast(`Column ${col+1}: loaded first ${ROWS} (ignored extra ${list.length-ROWS})`, 2600);
  } else if (list.length < ROWS){
    toast(`Column ${col+1}: loaded ${list.length} (kept the rest as-is)`, 2400);
  } else {
    toast(`Column ${col+1}: loaded 8/8 cells`, 2200);
  }
}

  // ====== Build UI ======
  function build(){
    colsEl.innerHTML = "";
    for (let c=0;c<COLS;c++){
      const col = document.createElement("div");
      col.className = "col";
      col.dataset.col = String(c);

      const head = document.createElement("div");
      head.className = "colHead";

      const row1 = document.createElement("div");
      row1.className = "colHeadRow";

      const nameBox = document.createElement("div");
      nameBox.className = "colName";const nameInput = document.createElement("input");
nameInput.className = "colTitleInput";
nameInput.type = "text";

nameInput.id = `colName-${c}`;
nameInput.value = String(state.colNames[c] || `Sample ${c+1}`);
nameInput.spellcheck = false;

nameInput.addEventListener("focus", () => {
  // Typing should replace the whole name (no manual backspace needed)
  setTimeout(() => { try { nameInput.select(); } catch(e){} }, 0);
});

nameInput.addEventListener("input", () => {
  // Keep blank -> default label, but store custom names when provided
  const v = String(nameInput.value || "").trim();
  state.colNames[c] = v ? v : `Sample ${c+1}`;
});

nameInput.addEventListener("keydown", (e) => {
  // Prevent spacebar from triggering page scroll when focused
  e.stopPropagation();
  if (e.key === "Enter") { nameInput.blur(); return; }
  if (e.key === "Tab") {
    e.preventDefault();
    const dir = e.shiftKey ? -1 : 1;
    const next = (c + dir + COLS) % COLS;
    try{ nameInput.blur(); }catch(_){}
    const nx = document.getElementById(`colName-${next}`);
    if (nx) { try{ nx.focus(); nx.select(); }catch(_){} }
    return;
  }
});

  // Cell name input (per selected cell)
  if (cellNameEl){
    const applyCellName = () => {
      const s = (state && state.selected && state.selected.has) ? state.selected : null;
      if (!s) return;
      const c = (s.col|0), r = (s.row|0);
      const raw = String(cellNameEl.value || '').trim();
      const v = raw ? raw : `C${r+1}`;
      if (!state.cellNames) state.cellNames = Array.from({length: COLS}, (_, cc) => Array.from({length: ROWS}, (_, rr) => `C${rr+1}`));
      state.cellNames[c][r] = v;

      // Keep cell display name in sync (filename · cellname)
      try{
        const cell = state.cells[c][r];
        if (cell && cell.left){
          const cur = String(cell.name || '').trim();
          let base = cur;
          if (cur.includes(' · ')) base = cur.split(' · ')[0].trim();
          // fallback base when empty
          if (!base) base = 'loaded';
          cell.name = base + ' · ' + v;
        }
      }catch(_){ }

      // Refresh visible labels immediately (cells, footer, editors)
      try{ updateCellUI(c, r); }catch(_){ }
      try{ updateColUI(c); }catch(_){ }
      try{ updateInspector(); }catch(_){ }

      // If Slice Editor is open and points at this cell, refresh its UI
      try{
        if (splitOverlayEl && splitOverlayEl.style.display !== 'none' && splitCol === c){
          splitUpdateTitle();
          splitUpdateInfo && splitUpdateInfo();
          splitDraw && splitDraw();
        }
      }catch(_){ }

      // If Wave Editor is open on this cell, refresh its title
      try{ if (waveOverlayEl && waveOverlayEl.style.display !== 'none' && waveCol === c && waveRow === r) waveUpdateTitle(); }catch(_){ }


    };
    cellNameEl.addEventListener('input', applyCellName);
    cellNameEl.addEventListener('change', applyCellName);

    // Match column name UX: focus selects all, Enter commits+blurs so arrow keys work immediately
    cellNameEl.addEventListener('focus', () => {
      setTimeout(() => { try { cellNameEl.select(); } catch(e){} }, 0);
    });
    cellNameEl.addEventListener('keydown', (e) => {
      e.stopPropagation();
      if (e.key === 'Enter') {
        try{ applyCellName(); }catch(_){}
        cellNameEl.blur();
      }
    });
    cellNameEl.addEventListener('blur', () => { try{ applyCellName(); }catch(_){} });
    cellNameEl.addEventListener('click', (e) => e.stopPropagation());
  }


nameInput.addEventListener("click", (e) => e.stopPropagation());nameBox.appendChild(nameInput);
const btns = document.createElement("div");
      btns.className = "colBtns";

      const loadSplitBtn = mkBtn("Load+Slice", "tiny", async () => {
        try{ openSplitEditor(c); }catch(e){ showFatal(e); }
      }, "Pick one sample, then split it into 8 slices with the new editor (zoom, L/M/R, Z auto-norm).");

      const load8Btn = mkBtn("Load 8", "tiny secondary", async () => {
        state.pick = { kind: "colmulti", col: c, row: null };
        fileInput.value = "";
        fileInput.multiple = true;
        fileInput.click();
      }, "Load 8 files at once into this column (top → bottom). ");

      const playBtn = mkBtn("▶", "tiny secondary", async () => {
        await playColumn(c);
      }, "Preview this whole column (play/stop). ");

      const exportBtn = mkBtn("Export", "tiny warn", () => {
        exportColumnDirect(c);
      }, "Export this column as WAV (Tempera-ready). ");

      const export8Btn = mkBtn("Export 8", "tiny warn secondary", () => {
        export8Cells(c);
      }, "Export the 8 cells as separate WAV files (zipped). Filenames use column name + cell name.");

      const clearBtn = mkBtn("Clear", "tiny danger secondary", () => {
        clearColumn(c);
      }, "Clear all 8 cells in this column.");

      btns.appendChild(loadSplitBtn);
      btns.appendChild(export8Btn);
      btns.appendChild(load8Btn);
      btns.appendChild(exportBtn);
      btns.appendChild(clearBtn);
      btns.appendChild(playBtn);

      row1.appendChild(nameBox);
      row1.appendChild(btns);

      head.appendChild(row1);

      const cellWrap = document.createElement("div");
      cellWrap.className = "cells";

      for (let r=0;r<ROWS;r++){
        const cellEl = document.createElement("div");
        cellEl.className = "cell";
        cellEl.dataset.col = String(c);
        cellEl.dataset.row = String(r);
        cellEl.draggable = true;

        cellEl.innerHTML = `
  <div class="cellTop">
    <span class="tag">C${r+1}</span>
    <span class="tag warn mode" id="icMode-${c}-${r}">rate</span>
    <div class="icons">
      <span class="icon" id="icMute-${c}-${r}">M</span>
      <span class="icon" id="icRev-${c}-${r}">R</span>
    </div>
  </div>

  <div class="cellFile" id="fname-${c}-${r}"><span class="cellFname">empty</span><span class="cellCname">C1</span></div>
  <div class="cellTime" id="time-${c}-${r}">—</div>

  <div class="waveWrap">
    <canvas class="wave" id="wave-${c}-${r}" data-col="${c}" data-row="${r}" width="240" height="48"></canvas>
    <div class="waveBadge" title="Trim selection">✂</div>
  </div>

  </div>

  <div class="cellBtns">
    <div class="left">
      <button class="tiny secondary" data-action="clear">Clear</button>
      <button class="tiny secondary" data-action="play">▶</button>
      <button class="tiny secondary" data-action="load">Load</button>
    </div>
  </div>
`;

        // Cache frequently accessed DOM nodes for this cell (performance)
        const _wave = cellEl.querySelector("canvas.wave");
        __cellDom[c][r] = {
          cellEl,
          wave: _wave,
          fnameEl: cellEl.querySelector(".cellFile"),
          timeEl: cellEl.querySelector(".cellTime"),
          icMute: cellEl.querySelector(`#icMute-${c}-${r}`),
          icRev:  cellEl.querySelector(`#icRev-${c}-${r}`),
          icMode: cellEl.querySelector(`#icMode-${c}-${r}`)
        };


        // Click to select
        cellEl.addEventListener("click", (e) => {
          const actBtn = e.target.closest("button");
          // Click on waveform opens Wave Editor (foundation)
          const waveHit = e.target.closest("canvas.wave");
          if (waveHit && !actBtn){
            setSelected(c, r);
            openWaveEditor(c, r);
            return;
          }

          if (actBtn){
            const action = actBtn.dataset.action;
            if (action === "play") {
              playCell(c,r, cellEl);
            } else if (action === "load") {
              setSelected(c,r);
              state.pick = { kind: "cell", col: c, row: r };
              fileInput.value = "";
              fileInput.multiple = false;
              fileInput.click();
            } else if (action === "clear") {
              clearCell(c,r);
            }
            return;
          }
          // select
          setSelected(c,r);
        });

        // double click => play
        cellEl.addEventListener("dblclick", () => playCell(c,r, cellEl));

        // Drag/drop: files or cell swap/copy
        cellEl.addEventListener("dragstart", (e) => {
          cellEl.classList.add("dragSrc");
          const payload = JSON.stringify({col:c,row:r});
          e.dataTransfer.setData("application/x-cell", payload);
          e.dataTransfer.setData("text/plain", payload);
          e.dataTransfer.effectAllowed = "copyMove";
        });
        cellEl.addEventListener("dragend", () => cellEl.classList.remove("dragSrc"));
        cellEl.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.stopPropagation();
          cellEl.classList.add("dragOver");
        });
        cellEl.addEventListener("dragleave", (e) => { e.stopPropagation(); cellEl.classList.remove("dragOver"); });
        cellEl.addEventListener("drop", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          cellEl.classList.remove("dragOver");

          const file = e.dataTransfer.files && e.dataTransfer.files[0];
          if (file){
            await loadFileIntoCell(c,r,file);
            return;
          }

          let data = e.dataTransfer.getData("application/x-cell");
          if (!data) data = e.dataTransfer.getData("text/plain");
          if (!data) return;
          try{
            const src = JSON.parse(data);
            if (src.col === c && src.row === r) return;

            const copy = e.altKey; // Alt = copy
            if (copy){
              copyCell(src.col, src.row, c, r);
              toast(`Copied cell → column ${c+1}/Cell `);
            }else{
              swapCells(src.col, src.row, c, r);
              toast(`Swapped cells`);
            }

            updateCellUI(src.col, src.row);
            updateCellUI(c,r);
            updateColUI(src.col);
            updateColUI(c);

            // keep selection stable
            if (state.selected.has){
              setSelected(state.selected.col, state.selected.row);
            }

          }catch{}
        });

        cellWrap.appendChild(cellEl);
      }

      col.appendChild(head);
      col.appendChild(cellWrap);

      // Column drop => Load+Slice
      col.addEventListener("dragover", (e) => { e.preventDefault(); col.classList.add("dragover"); });
      col.addEventListener("dragleave", () => col.classList.remove("dragover"));
      col.addEventListener("drop", async (e) => {
        e.preventDefault();
        col.classList.remove("dragover");
        const files = e.dataTransfer.files;
        if (files && files.length){
          if (files.length >= 2){
            await loadFilesIntoColumnCells(c, files);
          } else {
            await loadFileSplitIntoColumn(c, files[0]);
          }
        }
      });

      colsEl.appendChild(col);
    }

    updateAllTimeLabels();
    updateAllUIBatched(6);

    // default select 1st cell
    setSelected(0,0);
  }

  function mkBtn(text, cls, onClick, title){
    const b = document.createElement("button");
    b.textContent = text;
    b.className = cls;
    b.type = "button";
    if (title) b.title = String(title);
    b.addEventListener("click", onClick);
    return b;
  }

  // ====== UI updates ======
  function updateSpecLine(){
    const cellFrames = getCellFrames(state.selected.row);
    const colFrames = getColFrames();
    const mode = tempoModeEl.checked ? "Tempo" : "Fixed";
    const bpm = Number(bpmEl.value || 120);
    const beats = Number(beatsPerCellEl.value || 1);

    let msg = "";
    msg += `<span class="spec">${mode}</span>`;
    msg += `<span class="spec">SR ${SR} Hz</span>`;
    msg += `<span class="spec">cell ${cellFrames} frames (${seconds(cellFrames).toFixed(6)}s)</span>`;
    msg += `<span class="spec">col ${colFrames} frames (${seconds(colFrames).toFixed(6)}s)</span>`;

    if (!tempoModeEl.checked){
      msg += `<span class="spec">2^20 points/col = ${TOTAL_SAMPLE_POINTS}</span>`;
      msg += `<span class="spec">${(FIXED_COL_FRAMES/SR).toFixed(8)}s/col</span>`;
    } else {
      msg += `<span class="spec">${bpm} BPM</span>`;
      msg += `<span class="spec">${beats} beats/cell</span>`;
    }

    specLine.innerHTML = msg;
  }

  function updateAllTimeLabels(){
    const rowFrames = getCellFramesArray();
    for (let c=0;c<COLS;c++){
      let t = 0;
      for (let r=0;r<ROWS;r++){
        const el = document.getElementById(`time-${c}-${r}`);
        const s0 = seconds(t);
        t += rowFrames[r];
        const s1 = seconds(t);
        if (el) el.textContent = `${s0.toFixed(3)}–${s1.toFixed(3)}s`;
      }
    }
  }

  function updateCellUI(col,row){
    const cell = state.cells[col][row];

    const dom = (__cellDom[col] && __cellDom[col][row]) ? __cellDom[col][row] : null;

    const fnameEl = dom ? dom.fnameEl : document.getElementById(`fname-${col}-${row}`);
    const icMute = dom ? dom.icMute : document.getElementById(`icMute-${col}-${row}`);
    const icRev  = dom ? dom.icRev  : document.getElementById(`icRev-${col}-${row}`);
    const icMode = dom ? dom.icMode : document.getElementById(`icMode-${col}-${row}`);
    const wave = dom ? dom.wave : document.getElementById(`wave-${col}-${row}`);

    if (fnameEl){
      if (!cell.left){
        const fn = fnameEl.querySelector('.cellFname');
        const cn = fnameEl.querySelector('.cellCname');
        if (fn) fn.textContent = 'empty';
        if (cn) cn.textContent = '';
      } else {
        const dispCell = (state.cellNames && state.cellNames[col] && state.cellNames[col][row] != null) ? String(state.cellNames[col][row]).trim() : `C${row+1}`;
        const raw = String(cell.name || '').trim();
        let filePart = raw;
        // If name is like "file.wav · C1" keep only file part for the left span
        if (raw.includes('·')) filePart = raw.split('·')[0].trim();
        const fn = fnameEl.querySelector('.cellFname');
        const cn = fnameEl.querySelector('.cellCname');
        if (fn && fn.textContent !== filePart) fn.textContent = filePart || 'loaded';
        if (cn && cn.textContent !== dispCell) cn.textContent = dispCell;
        // Backward compatibility: if spans are missing, fall back to old behavior
        if (!fn || !cn){
          const _t = cell.name || 'loaded';
          if (fnameEl.textContent !== _t) fnameEl.textContent = _t;
        }
      }
    }

    if (icMute){
      icMute.classList.toggle("on", !!cell.settings.mute);
      if (icMute.title !== "Mute") icMute.title = "Mute";
    }
    if (icRev){
      icRev.classList.toggle("on", !!cell.settings.reverse);
      if (icRev.title !== "Reverse") icRev.title = "Reverse";
    }
    if (icMode){
      icMode.textContent = cell.settings.fitMode;
      if (icMode.title !== "Fit mode") icMode.title = "Fit mode";
    }

    if (wave){
      // Show scissors affordance only when trimming is available (source longer than cell duration)
      try{
        const cellFrames = getCellFrames(row);
        const key = (cell.editorKey && sourceStore && sourceStore.has(cell.editorKey)) ? cell.editorKey : (cell.sourceKey || (cell.origin && cell.origin.split && cell.origin.split.sourceKey) || "");
        const canTrim = !!(cell.allowWaveEditor || (key && sourceStore && sourceStore.has(key) && (sourceStore.get(key).L.length > cellFrames)));

        const had = wave.classList.contains("scissors");
        if (canTrim && !had) wave.classList.add("scissors");
        else if (!canTrim && had) wave.classList.remove("scissors");

        const wrap = wave.closest(".waveWrap");
        const badge = wrap ? wrap.querySelector(".waveBadge") : null;
        if (badge){
          const want = canTrim ? "block" : "none";
          if (badge.style.display !== want) badge.style.display = want;
        }

        // Only mark dirty if affordance changed (the actual waveform draw is handled elsewhere)
        if (canTrim !== had) markWaveDirty(col, row);
      }catch(_){}
    }
    // Waveform redraw diffing: mark dirty when what we show would change
    if (wave){
      try{
        const pLen = cell.peaks ? cell.peaks.length : 0;
        const sk = cell.sourceKey || (cell.origin && cell.origin.split && cell.origin.split.sourceKey) || "";
        const ts = (typeof cell.trimStartSrcFrames === "number") ? cell.trimStartSrcFrames : -1;
        const tl2 = (typeof cell.trimLenSrcFrames === "number") ? cell.trimLenSrcFrames : -1;
        const ss = (typeof cell.selStartFrames === "number") ? cell.selStartFrames : 0;
        const sl = (typeof cell.selLenFrames === "number") ? cell.selLenFrames : 0;
        const s = cell.settings || {};
        const wKey = [
          pLen, sk, ss, sl, ts, tl2,
          (s.fitMode||""), (s.reverse?1:0), (s.mute?1:0),
          Number(s.gain||0).toFixed(4),
          Math.round(Number(s.fadeInMs||0)), Math.round(Number(s.fadeOutMs||0))
        ].join("|");
        const prev = wave.dataset.wkey || "";
        if (prev !== wKey){
          wave.dataset.wkey = wKey;
          markWaveDirty(col, row);
        }
      }catch(_){}
    }


    // selected highlight
    const cellEl = dom ? dom.cellEl : colsEl.querySelector(`.cell[data-col="${col}"][data-row="${row}"]`);
    if (cellEl){
      cellEl.classList.toggle("selected", state.selected.has && state.selected.col===col && state.selected.row===row);
    }
  }

  function updateColUI(col){
    // update loaded state + meta
    const colEl = colsEl.querySelector(`.col[data-col="${col}"]`);
    const any = state.cells[col].some(cell => !!cell.left);

    if (colEl){
      colEl.classList.toggle("loaded", any);
    }
  }


  function updateAllUI(){
    for (let c=0;c<COLS;c++){
      for (let r=0;r<ROWS;r++) updateCellUI(c,r);
      updateColUI(c);
    }
    updateInspector();
  }

  // Batched UI refresh to avoid long main-thread stalls (Safari can crash on huge synchronous redraws)
  function updateAllUIBatched(batchCells=6){
    const coords = [];
    for (let c=0;c<COLS;c++){
      for (let r=0;r<ROWS;r++) coords.push([c,r]);
    }
    let i = 0;
    function step(){
      const end = Math.min(coords.length, i + Math.max(1, batchCells|0));
      for (; i<end; i++){
        const [c,r] = coords[i];
        updateCellUI(c,r);
      }
      if (i < coords.length){
        requestAnimationFrame(step);
        return;
      }
      // column UI can also be heavy; do it after cells
      for (let c=0;c<COLS;c++) updateColUI(c);
      updateInspector();
    }
    requestAnimationFrame(step);
  }


  // ====== Selection + Inspector ======
  
  function scrollCellIntoSafeCenter(el){
    // Old behavior centered the cell; new behavior keeps it inside the "safe" viewport
    // bounded by header (top) and inspector/footer (bottom), with minimal scrolling.
    if (!el) return;

    const header = document.querySelector("header");
    const insp = document.getElementById("inspector"); // footer/inspector bar
    const headerH = header ? header.getBoundingClientRect().height : 0;
    const inspH = insp ? insp.getBoundingClientRect().height : 0;

    const margin = 12;

    const rect = el.getBoundingClientRect();
    const safeTop = headerH + margin;
    const safeBottom = window.innerHeight - inspH - margin;
    const safeLeft = margin;
    const safeRight = window.innerWidth - margin;

    let dy = 0;
    if (rect.top < safeTop) dy = rect.top - safeTop;
    else if (rect.bottom > safeBottom) dy = rect.bottom - safeBottom;

    let dx = 0;
    if (rect.left < safeLeft) dx = rect.left - safeLeft;
    else if (rect.right > safeRight) dx = rect.right - safeRight;

    if (dx === 0 && dy === 0) return;

    try{
      window.scrollBy({ top: dy, left: dx, behavior: "auto" });
    }catch(_){
      window.scrollBy(dx, dy);
    }
  }

function setSelected(col,row){
    state.selected = { col, row, has: true };
    // update cell highlight quickly
    for (let c=0;c<COLS;c++){
      for (let r=0;r<ROWS;r++){
        const cellEl = colsEl.querySelector(`.cell[data-col="${c}"][data-row="${r}"]`);
        if (cellEl){
          cellEl.classList.toggle("selected", c===col && r===row);
        }
      }
    }
    updateInspector();
    // Keep selection visible when navigating with keyboard
    try{
      const selEl = colsEl.querySelector(`.cell[data-col="${col}"][data-row="${row}"]`);
      if (selEl) scrollCellIntoSafeCenter(selEl);
    }catch(_){ }
  }

  function getSelectedCell(){
    if (!state.selected.has) return null;
    return state.cells[state.selected.col][state.selected.row];
  }

  function getCell(col,row){
    try{ return state.cells[col]?.[row] ?? null; }catch(_){ return null; }
  }


  function updateInspector(){
    // Diff-only inspector updates: only touch DOM when values changed
    if (!state.selected.has){
      if (__inspCache.selKey !== null){
        __inspCache = { selKey: null };
      }
      if (inspTitleEl.textContent !== "Cell settings") inspTitleEl.textContent = "Cell settings";
      if (inspDescEl.textContent !== "Select a cell.") inspDescEl.textContent = "Select a cell.";
      if (cellInfoEl && cellInfoEl.textContent !== "—") cellInfoEl.textContent = "—";
      // disable buttons in empty selection
      if (!inspPlayBtn.disabled) inspPlayBtn.disabled = true;
      if (!inspNormalizeBtn.disabled) inspNormalizeBtn.disabled = true;
      return;
    }

    const {col,row} = state.selected;
    const cell = state.cells[col][row];
    const selKey = `${col}:${row}:${cell.sourceKey||""}`;

    if (__inspCache.selKey !== selKey){
      __inspCache = { selKey };
    }

    // Info (mostly stable unless selection/source/tempo changes)
    const cellFrames = getCellFrames(row);
    const info = [];
    info.push(`Target: ${cellFrames} frames (${seconds(cellFrames).toFixed(6)}s)`);
    (function(){
      let srcFrames = 0;
      try{
        const key = cell.sourceKey || "";
        const src = (key && sourceStore && sourceStore.has(key)) ? sourceStore.get(key) : null;
        srcFrames = (src && src.L) ? src.L.length : 0;
      }catch(_){}
      const showFrames = srcFrames || (cell.left ? cell.left.length : 0);
      info.push(`Source: ${showFrames ? `${showFrames} frames (${seconds(showFrames).toFixed(4)}s)` : "—"}`);
    })();
    const infoText = info.join("\n");
    if (__inspCache.infoText !== infoText){
      if (cellInfoEl) cellInfoEl.textContent = infoText;
      __inspCache.infoText = infoText;
    }

    const titleText = `${getColDisplayName(col)} — ${getCellDisplayName(col, row)}`;
    if (__inspCache.titleText !== titleText){
      inspTitleEl.textContent = titleText;
      __inspCache.titleText = titleText;
    }

    let descText = cell.left ? (cell.name || "loaded") : "empty";
    // If name is formatted as 'filename · <cell name>', hide the redundant cell name in the inspector footer.
    if (cell.left && cell && typeof cell.name === 'string' && cell.name.includes('·')){
      const parts = cell.name.split('·');
      const leftPart = (parts[0]||'').trim();
      const rightPart = parts.slice(1).join('·').trim();
      const dn = getCellDisplayName(col, row);
      if (leftPart && rightPart && rightPart === dn){
        descText = leftPart;
      }
    }
    
      if (cellNameEl){ const v = getCellDisplayName(col, row); if (cellNameEl.value !== v) cellNameEl.value = v; }
if (__inspCache.descText !== descText){
      inspDescEl.textContent = descText;
      __inspCache.descText = descText;
    }

    // Volume
    const gainStr = String(cell.settings.gain);
    if (__inspCache.gainStr !== gainStr){
      volEl.value = gainStr;
      __inspCache.gainStr = gainStr;
    }
    const gainLabel = `${cell.settings.gain.toFixed(2)}×`;
    if (__inspCache.gainLabel !== gainLabel){
      volValEl.textContent = gainLabel;
      __inspCache.gainLabel = gainLabel;
    }

    // Fade in/out
    const fiStr = String(cell.settings.fadeInMs);
    if (__inspCache.fiStr !== fiStr){
      fadeInEl.value = fiStr;
      __inspCache.fiStr = fiStr;
    }
    const fiLbl = String(Math.round(cell.settings.fadeInMs));
    if (__inspCache.fiLbl !== fiLbl){
      fadeInValEl.textContent = fiLbl;
      __inspCache.fiLbl = fiLbl;
    }

    const foStr = String(cell.settings.fadeOutMs);
    if (__inspCache.foStr !== foStr){
      fadeOutEl.value = foStr;
      __inspCache.foStr = foStr;
    }
    const foLbl = String(Math.round(cell.settings.fadeOutMs));
    if (__inspCache.foLbl !== foLbl){
      fadeOutValEl.textContent = foLbl;
      __inspCache.foLbl = foLbl;
    }

    // Fit mode
    const fit = cell.settings.fitMode;
    if (__inspCache.fit !== fit){
      fitModeEl.value = fit;
      fitValEl.textContent = fit;
      __inspCache.fit = fit;
    }

    // Switches
    const mute = !!cell.settings.mute;
    if (__inspCache.mute !== mute){
      muteEl.checked = mute;
      __inspCache.mute = mute;
    }
    const rev = !!cell.settings.reverse;
    if (__inspCache.rev !== rev){
      reverseEl.checked = rev;
      __inspCache.rev = rev;
    }

    // Disable inspector buttons when empty?
    const has = !!cell.left;
    if (__inspCache.has !== has){
      inspPlayBtn.disabled = !has;
      inspNormalizeBtn.disabled = !has;
      __inspCache.has = has;
    }

    // Reflect selection cell UI (icons/wave affordances) — but updateCellUI is itself cheapened
    updateCellUI(col,row);
  }

  function invalidateCellCache(col,row){
    const cell = state.cells[col][row];
    cell.cache = { key:"", L:null, R:null, frames:0 };
  }

  function copySettings(fromCell, toCell){
    toCell.settings.gain = fromCell.settings.gain;
    toCell.settings.mute = fromCell.settings.mute;
    toCell.settings.reverse = fromCell.settings.reverse;
    toCell.settings.fadeInMs = fromCell.settings.fadeInMs;
    toCell.settings.fadeOutMs = fromCell.settings.fadeOutMs;
    toCell.settings.fitMode = fromCell.settings.fitMode;
    toCell.cache = { key:"", L:null, R:null, frames:0 };
  }

  // Inspector events

  // Undo capture/commit for inspector controls
  [volEl, fadeInEl, fadeOutEl, fitModeEl, muteEl, reverseEl].forEach(el => {
    if (!el) return;
    el.addEventListener("pointerdown", captureSettingsUndo);
    el.addEventListener("focus", captureSettingsUndo);
    el.addEventListener("change", commitSettingsUndo);
  });
  volEl.addEventListener("input", () => {
    const cell = getSelectedCell(); if (!cell) return;
    cell.settings.gain = Number(volEl.value);
    volValEl.textContent = `${cell.settings.gain.toFixed(2)}×`;
    invalidateCellCache(state.selected.col, state.selected.row);
    updateCellUI(state.selected.col, state.selected.row);
  });

  fadeInEl.addEventListener("input", () => {
    const cell = getSelectedCell(); if (!cell) return;
    cell.settings.fadeInMs = Number(fadeInEl.value);
    fadeInValEl.textContent = String(Math.round(cell.settings.fadeInMs));
    invalidateCellCache(state.selected.col, state.selected.row);
    updateCellUI(state.selected.col, state.selected.row);
  });

  fadeOutEl.addEventListener("input", () => {
    const cell = getSelectedCell(); if (!cell) return;
    cell.settings.fadeOutMs = Number(fadeOutEl.value);
    fadeOutValEl.textContent = String(Math.round(cell.settings.fadeOutMs));
    invalidateCellCache(state.selected.col, state.selected.row);
    updateCellUI(state.selected.col, state.selected.row);
  });

  fitModeEl.addEventListener("change", () => {
    const cell = getSelectedCell(); if (!cell) return;
    cell.settings.fitMode = fitModeEl.value;
    fitValEl.textContent = cell.settings.fitMode;
    invalidateCellCache(state.selected.col, state.selected.row);
    updateCellUI(state.selected.col, state.selected.row);
  });

  muteEl.addEventListener("change", () => {
    const cell = getSelectedCell(); if (!cell) return;
    cell.settings.mute = !!muteEl.checked;
    invalidateCellCache(state.selected.col, state.selected.row);
    updateCellUI(state.selected.col, state.selected.row);
  });

  reverseEl.addEventListener("change", () => {
    const cell = getSelectedCell(); if (!cell) return;
    cell.settings.reverse = !!reverseEl.checked;
    invalidateCellCache(state.selected.col, state.selected.row);
    updateCellUI(state.selected.col, state.selected.row);
  });

  inspPlayBtn.addEventListener("click", () => {
    if (!state.selected.has) return;
    const {col,row} = state.selected;
    const cellEl = colsEl.querySelector(`.cell[data-col="${col}"][data-row="${row}"]`);
    playCell(col,row, cellEl);
  });

  inspLoadBtn.addEventListener("click", () => {
    if (!state.selected.has) return;
    state.pick = { kind: "cell", col: state.selected.col, row: state.selected.row };
    fileInput.value = "";
    fileInput.multiple = false;
    fileInput.click();
  });

  inspClearBtn.addEventListener("click", () => {
    if (!state.selected.has) return;
    clearCell(state.selected.col, state.selected.row);
  });

  inspNormalizeBtn.addEventListener("click", () => {
    const cell = getSelectedCell(); if (!cell) return;
    normalizeCellGain(cell);
    invalidateCellCache(state.selected.col, state.selected.row);
    updateCellUI(state.selected.col, state.selected.row);
    updateInspector();
    toast("Normalized gain");
  });

  inspCopyToColBtn.addEventListener("click", () => {
    if (!state.selected.has) return;
    const from = getSelectedCell(); if (!from) return;
    const col = state.selected.col;
    for (let r=0;r<ROWS;r++){
      copySettings(from, state.cells[col][r]);
      updateCellUI(col,r);
    }
    toast("Settings copied → column");
  });

  inspCopyToAllBtn.addEventListener("click", () => {
    if (!state.selected.has) return;
    const from = getSelectedCell(); if (!from) return;
    for (let c=0;c<COLS;c++){
      for (let r=0;r<ROWS;r++){
        copySettings(from, state.cells[c][r]);
        updateCellUI(c,r);
      }
    }
    toast("Settings copied → all cells");
  });

  // ====== Swap / Copy cells ======
  function swapCells(c1,r1,c2,r2){
    const a = state.cells[c1][r1];
    const b = state.cells[c2][r2];
    state.cells[c1][r1] = b;
    state.cells[c2][r2] = a;
  }

  function copyCell(c1,r1,c2,r2){
    const src = state.cells[c1][r1];
    const dst = state.cells[c2][r2];

    state.cells[c2][r2] = {
      name: src.name,
      left: src.left ? new Float32Array(src.left) : null,
      right: src.right ? new Float32Array(src.right) : null,
      peaks: src.peaks ? new Float32Array(src.peaks) : null,
      settings: {
        gain: src.settings.gain,
        mute: src.settings.mute,
        reverse: src.settings.reverse,
        fadeInMs: src.settings.fadeInMs,
        fadeOutMs: src.settings.fadeOutMs,
        fitMode: src.settings.fitMode,
      },
      cache: { key:"", L:null, R:null, frames:0 }
    };
  }

  // ====== Clear ======
  function clearCell(col,row){
    stopPlayback();
    state.cells[col][row] = makeEmptyCell();
    updateCellUI(col,row);
    updateColUI(col);
    updateInspector();
    toast(`Cleared cell col ${col+1} Cel ${row+1}`);
  }

  function clearColumn(col){
    stopPlayback();
    for (let r=0;r<ROWS;r++){
      state.cells[col][r] = makeEmptyCell();
      updateCellUI(col,r);
    }
    updateColUI(col);
    toast(`Cleared column ${col+1}`);
  }

  function clearAll(){
    hardResetEngines();
    for (let c=0;c<COLS;c++){
      clearColumn(c);
    }

    // Reset column names to defaults
    for (let c=0;c<COLS;c++){
      state.colNames[c] = `Sample ${c+1}`;
      const el = document.getElementById(`colName-${c}`);
      if (el) el.value = state.colNames[c];
    }

    toast("Cleared everything");
  }

  // ====== Playback ======
  function makeAudioBufferFromLR(L,R){
    const ctx = getAudioCtx();
    const buf = ctx.createBuffer(2, L.length, SR);
    buf.copyToChannel(L, 0, 0);
    buf.copyToChannel(R, 1, 0);
    return buf;
  }

  async function playCell(col,row, cellEl){
    const cell = state.cells[col][row];
    if (!cell.left || !cell.right){
      toast("Cell is empty");
      return;
    }

    await ensureAudio();
    stopPlayback();

    const targetFrames = getCellFrames(row);
    const {L,R} = renderCellToTarget(cell, targetFrames);

    const buf = makeAudioBufferFromLR(L,R);

    const ctx = getAudioCtx();
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.connect(ctx.destination);

    if (cellEl){
      cellEl.classList.add("playing");
      state.currentCellEl = cellEl;
    }

    state.currentSrc = src;
    src.start(0);

    src.onended = () => {
      if (state.currentCellEl){
        state.currentCellEl.classList.remove("playing");
      }
      state.currentCellEl = null;
      state.currentSrc = null;
    };
  }

  async function playColumn(col){
    const rowFrames = getCellFramesArray();
    const colFrames = getColFrames();

    const outL = new Float32Array(colFrames);
    const outR = new Float32Array(colFrames);

    let any = false;
    let off = 0;
    for (let r=0;r<ROWS;r++){
      const cell = state.cells[col][r];
      if (cell.left && cell.right) any = true;

      const frames = rowFrames[r];
      const out = renderCellToTarget(cell, frames);
      outL.set(out.L, off);
      outR.set(out.R, off);
      off += frames;
    }

    if (!any){ toast("Sample column is empty"); return; }

    await ensureAudio();
    stopPlayback();

    const buf = makeAudioBufferFromLR(outL, outR);
    const ctx = getAudioCtx();
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.connect(ctx.destination);
    state.currentSrc = src;
    src.start(0);
    toast(`Play column ${col+1}`);
  }

  // ====== WAV Encoding + Export ======
  function floatToInt16(x){
    x = clamp(x, -1, 1);
    return x < 0 ? Math.round(x * 32768) : Math.round(x * 32767);
  }

  function encodeWav16Stereo(L, R){
    const numFrames = L.length;
    const numChannels = 2;
    const bitsPerSample = 16;
    const bytesPerSample = bitsPerSample / 8;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = SR * blockAlign;
    const dataSize = numFrames * blockAlign;

    const ab = new ArrayBuffer(44 + dataSize);
    const dv = new DataView(ab);

    function writeAscii(off, s){
      for (let i=0;i<s.length;i++) dv.setUint8(off+i, s.charCodeAt(i) & 0xFF);
    }

    writeAscii(0, "RIFF");
    dv.setUint32(4, 36 + dataSize, true);
    writeAscii(8, "WAVE");
    writeAscii(12, "fmt ");
    dv.setUint32(16, 16, true);
    dv.setUint16(20, 1, true);
    dv.setUint16(22, 2, true);
    dv.setUint32(24, SR, true);
    dv.setUint32(28, byteRate, true);
    dv.setUint16(32, blockAlign, true);
    dv.setUint16(34, bitsPerSample, true);
    writeAscii(36, "data");
    dv.setUint32(40, dataSize, true);

    let o = 44;
    for (let i=0;i<numFrames;i++){
      dv.setInt16(o, floatToInt16(L[i]), true); o += 2;
      dv.setInt16(o, floatToInt16(R[i]), true); o += 2;
    }

    return new Blob([ab], {type:"audio/wav"});
  }


  // --- WAV bytes for ZIP (same format as encodeWav16Stereo, but returns Uint8Array)
  function encodeWav16StereoBytes(L, R){
    const numFrames = L.length;
    const numChannels = 2;
    const bitsPerSample = 16;
    const bytesPerSample = bitsPerSample / 8;
    const blockAlign = numChannels * bytesPerSample;
    const byteRate = SR * blockAlign;
    const dataSize = numFrames * blockAlign;

    const ab = new ArrayBuffer(44 + dataSize);
    const dv = new DataView(ab);

    function writeAscii(off, s){
      for (let i=0;i<s.length;i++) dv.setUint8(off+i, s.charCodeAt(i) & 0xFF);
    }

    writeAscii(0, "RIFF");
    dv.setUint32(4, 36 + dataSize, true);
    writeAscii(8, "WAVE");
    writeAscii(12, "fmt ");
    dv.setUint32(16, 16, true);
    dv.setUint16(20, 1, true);
    dv.setUint16(22, 2, true);
    dv.setUint32(24, SR, true);
    dv.setUint32(28, byteRate, true);
    dv.setUint16(32, blockAlign, true);
    dv.setUint16(34, bitsPerSample, true);
    writeAscii(36, "data");
    dv.setUint32(40, dataSize, true);

    let o = 44;
    for (let i=0;i<numFrames;i++){
      dv.setInt16(o, floatToInt16(L[i]), true); o += 2;
      dv.setInt16(o, floatToInt16(R[i]), true); o += 2;
    }

    return new Uint8Array(ab);
  }

  function exportColumnBytes(col){
    const rowFrames = getCellFramesArray();
    const colFrames = getColFrames();

    const outL = new Float32Array(colFrames);
    const outR = new Float32Array(colFrames);

    let off = 0;
    for (let r=0;r<ROWS;r++){
      const cell = state.cells[col][r];
      const frames = rowFrames[r];
      const out = renderCellToTarget(cell, frames);
      outL.set(out.L, off);
      outR.set(out.R, off);
      off += frames;
    }
    return encodeWav16StereoBytes(outL, outR);
  }

  // --- Minimal ZIP (STORE, no compression) for reliable single-download export
  const _crcTable = (() => {
    const table = new Uint32Array(256);
    for (let i=0;i<256;i++){
      let c = i;
      for (let k=0;k<8;k++){
        c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
      }
      table[i] = c >>> 0;
    }
    return table;
  })();

  function crc32(u8){
    let c = 0xFFFFFFFF;
    for (let i=0;i<u8.length;i++){
      c = _crcTable[(c ^ u8[i]) & 0xFF] ^ (c >>> 8);
    }
    return (c ^ 0xFFFFFFFF) >>> 0;
  }

  function dosTimeDate(d){
    const dt = d || new Date();
    let year = dt.getFullYear();
    if (year < 1980) year = 1980;
    const month = dt.getMonth() + 1;
    const day = dt.getDate();
    const hours = dt.getHours();
    const mins = dt.getMinutes();
    const secs = Math.floor(dt.getSeconds() / 2);

    const dosTime = ((hours & 0x1F) << 11) | ((mins & 0x3F) << 5) | (secs & 0x1F);
    const dosDate = (((year - 1980) & 0x7F) << 9) | ((month & 0x0F) << 5) | (day & 0x1F);
    return {dosTime, dosDate};
  }

  function u32le(n){
    const b = new Uint8Array(4);
    b[0] = n & 0xFF;
    b[1] = (n >>> 8) & 0xFF;
    b[2] = (n >>> 16) & 0xFF;
    b[3] = (n >>> 24) & 0xFF;
    return b;
  }
  function u16le(n){
    const b = new Uint8Array(2);
    b[0] = n & 0xFF;
    b[1] = (n >>> 8) & 0xFF;
    return b;
  }

  function zipStore(files){
    // files: [{name: string, data: Uint8Array}]
    const enc = new TextEncoder();
    const now = new Date();
    const {dosTime, dosDate} = dosTimeDate(now);

    let offset = 0;
    const localParts = [];
    const centralParts = [];

    for (const f of files){
      const nameBytes = enc.encode(f.name);
      const data = f.data;
      const crc = crc32(data);
      const size = data.length;

      // Local file header
      localParts.push(u32le(0x04034b50));
      localParts.push(u16le(20));       // version needed
      localParts.push(u16le(0));        // flags
      localParts.push(u16le(0));        // compression (0=store)
      localParts.push(u16le(dosTime));
      localParts.push(u16le(dosDate));
      localParts.push(u32le(crc));
      localParts.push(u32le(size));
      localParts.push(u32le(size));
      localParts.push(u16le(nameBytes.length));
      localParts.push(u16le(0));        // extra len
      localParts.push(nameBytes);
      localParts.push(data);

      const localHeaderSize = 30 + nameBytes.length;
      const localTotal = localHeaderSize + size;

      // Central directory header
      centralParts.push(u32le(0x02014b50));
      centralParts.push(u16le(20));      // version made by
      centralParts.push(u16le(20));      // version needed
      centralParts.push(u16le(0));       // flags
      centralParts.push(u16le(0));       // compression
      centralParts.push(u16le(dosTime));
      centralParts.push(u16le(dosDate));
      centralParts.push(u32le(crc));
      centralParts.push(u32le(size));
      centralParts.push(u32le(size));
      centralParts.push(u16le(nameBytes.length));
      centralParts.push(u16le(0));       // extra
      centralParts.push(u16le(0));       // comment
      centralParts.push(u16le(0));       // disk start
      centralParts.push(u16le(0));       // internal attr
      centralParts.push(u32le(0));       // external attr
      centralParts.push(u32le(offset));  // local header offset
      centralParts.push(nameBytes);

      offset += localTotal;
    }

    // Compute central directory size
    const centralOffset = offset;

    const centralBlob = new Blob(centralParts, {type:"application/octet-stream"});
    const localBlob = new Blob(localParts, {type:"application/octet-stream"});

    // Need sizes (sync): use byteLength sums ourselves
    const byteLen = (parts) => parts.reduce((s,p)=>s + (p.byteLength ?? p.size ?? 0), 0);
    const centralSize = byteLen(centralParts);
    const totalEntries = files.length;

    // End of central directory
    const endParts = [];
    endParts.push(u32le(0x06054b50));
    endParts.push(u16le(0)); // disk
    endParts.push(u16le(0)); // disk with central
    endParts.push(u16le(totalEntries));
    endParts.push(u16le(totalEntries));
    endParts.push(u32le(centralSize));
    endParts.push(u32le(centralOffset));
    endParts.push(u16le(0)); // comment len

    return new Blob([localBlob, centralBlob, new Blob(endParts)], {type:"application/zip"});
  }
  function exportColumnBlob(col){
    const rowFrames = getCellFramesArray();
    const colFrames = getColFrames();

    const outL = new Float32Array(colFrames);
    const outR = new Float32Array(colFrames);

    let off = 0;
    for (let r=0;r<ROWS;r++){
      const cell = state.cells[col][r];
      const frames = rowFrames[r];
      const out = renderCellToTarget(cell, frames);
      outL.set(out.L, off);
      outR.set(out.R, off);
      off += frames;
    }
    return encodeWav16Stereo(outL, outR);
  }

  function exportColumnDirect(col){
    const any = state.cells[col].some(cell => cell.left);
    if (!any){
      toast("Sample column is empty");
      return;
    }

    const blob = exportColumnBlob(col);
    const url = URL.createObjectURL(blob);

    const filename = formatNameForCol(col, getColFrames());

    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();

    setTimeout(() => URL.revokeObjectURL(url), 2000);
    toast(`Exported WAV col ${col+1}`);
  }

  function export8Cells(col){
    const rowFrames = getCellFramesArray();
    const colName = sanitizeFilename(state.colNames[col] || `Sample_${col+1}`);

    const files = [];
    for (let r=0; r<ROWS; r++){
      const cell = state.cells[col][r];
      if (!cell || !cell.left) continue;
      const frames = rowFrames[r];
      const out = renderCellToTarget(cell, frames);
      const wav = encodeWav16StereoBytes(out.L, out.R);
      const cellLabel = sanitizeFilename((state.cellNames && state.cellNames[col] && state.cellNames[col][r]) ? String(state.cellNames[col][r]) : `C${r+1}`);
      const fname = sanitizeFilename(`${colName}_${cellLabel}`) + ".wav";
      files.push({name: fname, data: wav});
    }

    if (!files.length){
      toast("Nothing to export in this column");
      return;
    }

    const zipBlob = zipStore(files);
    const url = URL.createObjectURL(zipBlob);
    const zipName = sanitizeFilename(`${colName}_Export8`) + ".zip";

    clickDownload(url, zipName);
    setTimeout(() => URL.revokeObjectURL(url), 3000);
    toast(`Exported ${files.length} cell(s) as ZIP`);
  }


  
  
  function showDownloadModal(items){
    dlModalItems = items || [];

    const dlModal = document.getElementById("dlModal");
    const dlModalList = document.getElementById("dlModalList");
    if (!dlModal || !dlModalList){
      // Modal not available (shouldn't happen), just fall back silently.
      return;
    }

    dlModalList.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const it of dlModalItems){
      const div = document.createElement("div");
      div.className = "dlItem";

      const lab = document.createElement("div");
      lab.className = "dlLabel";
      lab.innerHTML = `<div class="a">Sample ${it.col+1}</div><div class="b">${escapeHtml(it.filename)}</div>`;

      const a = document.createElement("a");
      a.href = it.url;
      a.download = it.filename;
      a.textContent = "Download";

      div.appendChild(lab);
      div.appendChild(a);
      frag.appendChild(div);
    }

    dlModalList.appendChild(frag);
    dlModal.classList.add("show");
    dlModal.setAttribute("aria-hidden","false");
  }

  function hideDownloadModal(){
    const dlModal = document.getElementById("dlModal");
    if (!dlModal) return;
    dlModal.classList.remove("show");
    dlModal.setAttribute("aria-hidden","true");
  }

  function revokeModalUrls(){
    for (const it of (dlModalItems || [])){
      try{ URL.revokeObjectURL(it.url); }catch{}
    }
    dlModalItems = [];
  }
    

  function clickDownload(url, filename){
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.style.display = "none";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  
  async function exportAllColumnsZip(){
    try{
      const files = [];
      const colFrames = getColFrames();

      
// Ask for a preset name (used for ZIP + preset JSON file name)
const def = `TCM_Preset_${getDateStamp()}`;
const presetName = await (window.openPresetNameOverlay ? window.openPresetNameOverlay(def) : openPresetNameOverlay(def));
if (!presetName){
  toast("Export cancelled.", 1200);
  return;
}
      // Make sure the preset JSON sorts AFTER audio files when extracted to a folder
      const presetJsonName = sanitizeFilename(`zz_TCM-Preset_${presetName}`) + ".json";


      for (let c=0; c<COLS; c++){
        const any = state.cells[c].some(cell => cell.left);
        if (!any) continue;

        const wavBytes = exportColumnBytes(c);
        const filename = formatNameForCol(c, colFrames);
        files.push({name: filename, data: wavBytes});
      }
      // Add preset JSON (keep it last in the ZIP for Tempera folder-load compatibility)
      const preset = {
      appVersion: APP_VERSION,
      appBuildDate: (typeof APP_BUILD_DATE !== "undefined" ? APP_BUILD_DATE : ""),
      changelog: (typeof CHANGELOG !== "undefined" ? CHANGELOG.slice() : []),
        app: "Tempera Cell Matrix",
        presetVersion: "v27-waveSel",
        createdAt: new Date().toISOString(),
sampleRootHint: computeSampleRootHintFromState(),
topFolders: computeTopFoldersFromState(),
        sampleRate: SR,
        channels: 2,
        colFrames,
        colNames: Array.from({length: COLS}, (_, c) => (state.colNames[c] || `Sample ${c+1}`)),
        cellNames: Array.from({length: COLS}, (_, c) => Array.from({length: ROWS}, (_, r) => (state.cellNames?.[c]?.[r] || `C${r+1}`))),
        tempo: {
          tempoMode: !!(tempoModeEl && tempoModeEl.checked),
          bpm: Number(bpmEl?.value || 120),
          beatsPerCell: Number(beatsPerCellEl?.value || 1),
        },
        options: {
          splitFit: !!(splitFitEl && splitFitEl.checked),
          normalizeOnLoad: !!(normalizeOnLoadEl && normalizeOnLoadEl.checked),
          nameTemplate: String(nameTemplateEl?.value || ""),
        },
        columns: Array.from({length: COLS}, (_, c) => ({
          index: c,
          name: state.colNames[c] || `Sample ${c+1}`,
          any: state.cells[c].some(cell => cell.left),
          cells: Array.from({length: ROWS}, (_, r) => ({
            row: r,
            name: state.cells[c][r].name || "",
            fileName: state.cells[c][r].origin?.fileName || state.cells[c][r].name || "",
            relPath: state.cells[c][r].origin?.relPath || "",
            origin: state.cells[c][r].origin || null,
            settings: { ...state.cells[c][r].settings },
            hasAudio: !!state.cells[c][r].left,
            sourceKey: state.cells[c][r].sourceKey || "",
            selStartFrames: (typeof state.cells[c][r].selStartFrames === "number") ? state.cells[c][r].selStartFrames : 0,
            selLenFrames: (typeof state.cells[c][r].selLenFrames === "number") ? state.cells[c][r].selLenFrames : getCellFrames(r),
          }))
        }))
      };
      const presetBytes = new TextEncoder().encode(JSON.stringify(preset, null, 2));
      files.push({ name: presetJsonName, data: presetBytes });


      if (!files.length){
        toast("Nothing to export");
        return;
      }

      toast(`Building ZIP (${files.length} file(s))...`, 1800);

      const zipBlob = zipStore(files);
      const url = URL.createObjectURL(zipBlob);

      const zipName = sanitizeFilename(`${presetName}_${getDateStamp()}`) + ".zip";
      clickDownload(url, zipName);

      setTimeout(() => URL.revokeObjectURL(url), 8000);
      toast(`Exported ZIP: ${files.length} column(s)`, 2200);
    }catch(err){
      console.error(err);
      toast(`Export failed: ${err?.message || err}`, 3500);
    }
  }

  // ====== Global events ======
  enableAudioBtn.addEventListener("click", async () => {
    try{
      await ensureAudio();
      toast("Audio enabled");
    }catch{
      toast("Could not start audio");
    }
  });
  exportAllBtn.addEventListener("click", () => { exportAllColumnsZip(); });
stopBtn.addEventListener("click", () => stopPlayback());


  function openHelp(){
    if (!helpOverlayEl) return;
    helpOverlayEl.classList.add("show");
    helpOverlayEl.setAttribute("aria-hidden", "false");
  }
  function closeHelp(){
    if (!helpOverlayEl) return;
    helpOverlayEl.classList.remove("show");
    helpOverlayEl.setAttribute("aria-hidden", "true");
  }

  if (helpBtn){
    helpBtn.addEventListener("click", () => openHelp());

  // ====== Preset import (relink samples from a folder) ======
  const importPresetBtn = document.getElementById("importPresetBtn");
  const presetFileInput = (() => {
    const el = document.getElementById("presetFileInput");
    if (el) return el;
    const i = document.createElement("input");
    i.type = "file";
    i.accept = "application/json,.json";
    i.id = "presetFileInput";
    i.style.position = "fixed";
    i.style.left = "-10000px";
    i.style.top = "0";
    i.style.opacity = "0";
    i.style.pointerEvents = "none";
    document.body.appendChild(i);
    return i;
  })();

  const presetFolderInput = (() => {
    const el = document.getElementById("presetFolderInput");
    if (el) return el;
    const i = document.createElement("input");
    i.type = "file";
    i.multiple = true;
    i.setAttribute("webkitdirectory", "");
    i.id = "presetFolderInput";
    i.style.position = "fixed";
    i.style.left = "-10000px";
    i.style.top = "0";
    i.style.opacity = "0";
    i.style.pointerEvents = "none";
    document.body.appendChild(i);
    return i;
  })();

  async function pickFolderFiles(){
    // Preferred: File System Access API (Chromium). Fallback: webkitdirectory input (Safari/Firefox).
    if (window.showDirectoryPicker){
      let dir;
      try{
        dir = await window.showDirectoryPicker({ mode: "read" });
      }catch(err){
        // User cancelled the picker – treat as a normal cancel, not an error.
        if (err && (err.name === "AbortError" || err.code === 20)) return [];
        // In some contexts (notably file://), showDirectoryPicker may exist but still be blocked.
        // Fall back to the directory <input> route for these cases.
        if (err && (err.name === "SecurityError" || err.name === "NotAllowedError" || err.name === "TypeError")){
          return await new Promise((resolve) => {
            presetFolderInput.value = "";
            presetFolderInput.onchange = () => resolve(Array.from(presetFolderInput.files || []));
            presetFolderInput.click();
          });
        }
        throw err;
      }
      const files = [];
      async function walk(handle, rel=""){
        for await (const [name, h] of handle.entries()){
          if (h.kind === "file"){
            const f = await h.getFile();
            f._relPath = (rel ? rel + "/" : "") + name;
            files.push(f);
          } else if (h.kind === "directory"){
            await walk(h, (rel ? rel + "/" : "") + name);
          }
        }
      }
      await walk(dir, "");
      return files;
    } else {
      // Safari / Firefox: prompt user with directory input
      return await new Promise((resolve) => {
        presetFolderInput.value = "";
        presetFolderInput.onchange = () => resolve(Array.from(presetFolderInput.files || []));
        presetFolderInput.click();
      });
    }
  }

  function gatherPresetFileHints(preset){
    const hints = [];
    try{
      const cols = preset?.columns;
      if (Array.isArray(cols)){
        for (let c=0;c<cols.length;c++){
          const cells = cols[c]?.cells;
          if (!Array.isArray(cells)) continue;
          for (const cell of cells){
            const rel = (cell?.relPath || cell?.origin?.relPath || "").toString();
            const fn  = (cell?.fileName || cell?.origin?.fileName || "").toString();
            const pick = rel || fn;
            if (pick) hints.push(pick);
          }
        }
      }
    }catch(_){}
    // unique, keep order
    const seen = new Set();
    const out = [];
    for (const h of hints){
      const k = h.toLowerCase();
      if (seen.has(k)) continue;
      seen.add(k);
      out.push(h);
      if (out.length >= 18) break;
    }
    return out;
  }

  function requestSampleFolder(preset){
    // In Safari, programmatic file input clicks often only work from a direct user gesture.
    // Show an overlay with a user-click "Choose folder…" button.
    return new Promise((resolve, reject) => {
      const overlay = document.getElementById("folderOverlay");
      const listEl = document.getElementById("folderOverlayList");
      const pickBtn = document.getElementById("folderOverlayPickBtn");
      const cancelBtn = document.getElementById("folderOverlayCancelBtn");
      const closeBtn = document.getElementById("folderOverlayClose");

      if (!overlay || !listEl || !pickBtn || !cancelBtn || !closeBtn){
        // Fallback (Chromium usually)
        pickFolderFiles().then(resolve).catch(reject);
        return;
      }

            const hints = gatherPresetFileHints(preset);
      const rootHint = computeRootHintFromPreset(preset);
      const tops = Array.isArray(preset?.topFolders) ? preset.topFolders : [];
      const topTxt = (tops && tops.length) ? ("Top folder(s): " + tops.slice(0,6).join(", ")) : "";

      const headLines = [];
      if (rootHint) headLines.push("Root hint: " + rootHint);
      if (topTxt) headLines.push(topTxt);

      const body = hints.length
        ? ("Looking for files like:\n- " + hints.join("\n- "))
        : "No filenames found in preset.";

      listEl.textContent = (headLines.length ? (headLines.join("\n") + "\n\n") : "") + body;
const cleanup = () => {
        overlay.classList.remove("show");
        overlay.setAttribute("aria-hidden","true");
        pickBtn.onclick = null;
        cancelBtn.onclick = null;
        closeBtn.onclick = null;
        overlay.onclick = null;
        window.removeEventListener("keydown", onKey);
      };

      const onKey = (e) => {
        if (e.key === "Escape"){
          cleanup();
          resolve([]);
        }
      };

      pickBtn.onclick = async () => {
        try{
          const files = await pickFolderFiles();
          cleanup();
          resolve(files);
        }catch(err){
          cleanup();
          reject(err);
        }
      };

      const cancel = () => { cleanup(); resolve([]); };
      cancelBtn.onclick = cancel;
      closeBtn.onclick = cancel;
      overlay.onclick = (e) => { if (e.target === overlay) cancel(); };

      window.addEventListener("keydown", onKey);
      overlay.classList.add("show");
      overlay.setAttribute("aria-hidden","false");
    });
  }

  
  function openRandom64FilterOverlay(){
    return new Promise((resolve) => {
      const ov = document.getElementById("filterOverlay");
      const incEl = document.getElementById("filterIncludeInput");
      const excEl = document.getElementById("filterExcludeInput");
      const btnSave = document.getElementById("filterOverlaySaveBtn");
      const btnCancel = document.getElementById("filterOverlayCancelBtn");
      const btnClear = document.getElementById("filterOverlayClearBtn");
      const btnClose = document.getElementById("filterOverlayClose");

      if (!ov || !incEl || !excEl || !btnSave || !btnCancel || !btnClear || !btnClose){
        // Fallback if overlay markup missing (shouldn't happen)
        resolve(null);
        return;
      }

      const curInc = (localStorage.getItem(FILTER_KEY_INCLUDE) || "");
      const curExc = (localStorage.getItem(FILTER_KEY_EXCLUDE) || "");
      incEl.value = curInc;
      excEl.value = curExc;

      const cleanup = () => {
        ov.classList.remove("show");
        ov.setAttribute("aria-hidden","true");
        btnSave.onclick = null;
        btnCancel.onclick = null;
        btnClear.onclick = null;
        btnClose.onclick = null;
        ov.onclick = null;
        window.removeEventListener("keydown", onKey);
      };

      const onKey = (e) => {
        if (e.key === "Escape"){
          cleanup();
          resolve(null);
        }
      };

      btnSave.onclick = () => {
        const inc = (incEl.value || "");
        const exc = (excEl.value || "");
        cleanup();
        resolve({inc, exc});
      };

      const cancel = () => { cleanup(); resolve(null); };
      btnCancel.onclick = cancel;
      btnClose.onclick = cancel;

      btnClear.onclick = () => {
        incEl.value = "";
        excEl.value = "";
      };

      ov.onclick = (e) => { if (e.target === ov) cancel(); };
      window.addEventListener("keydown", onKey);
      ov.classList.add("show");
      ov.setAttribute("aria-hidden","false");

      // focus include input
      setTimeout(() => incEl.focus(), 0);
    });
  }
  // Expose for Safari (avoids scope quirks)
  window.openRandom64FilterOverlay = openRandom64FilterOverlay;

function openPresetNameOverlay(defaultName){
  return new Promise((resolve) => {
    const ov = document.getElementById("presetNameOverlay");
    const input = document.getElementById("presetNameInput");
    const btnOk = document.getElementById("presetNameOkBtn");
    const btnCancel = document.getElementById("presetNameCancelBtn");
    const btnClose = document.getElementById("presetNameOverlayClose");
    if (!ov || !input || !btnOk || !btnCancel || !btnClose){
      // Fallback to browser prompt if overlay is unavailable
      const raw = prompt("Preset name (used for ZIP + preset JSON):", defaultName || "");
      if (raw == null) return resolve(null);
      const s = sanitizeFilename(raw);
      return resolve(s || sanitizeFilename(defaultName || "TCM_Preset"));
    }

    input.value = String(defaultName || "");
    input.select?.();

    const cleanup = () => {
      ov.classList.remove("show");
      ov.setAttribute("aria-hidden","true");
      window.removeEventListener("keydown", onKey);
      btnOk.onclick = null;
      btnCancel.onclick = null;
      btnClose.onclick = null;
      ov.onclick = null;
    };

    const finish = (val) => {
      cleanup();
      resolve(val);
    };

    const onKey = (e) => {
      if (e.key === "Escape"){ e.preventDefault(); finish(null); }
      if (e.key === "Enter"){
        e.preventDefault();
        const s = sanitizeFilename(input.value || "");
        finish(s || sanitizeFilename(defaultName || "TCM_Preset"));
      }
    };

    btnOk.onclick = () => {
      const s = sanitizeFilename(input.value || "");
      finish(s || sanitizeFilename(defaultName || "TCM_Preset"));
    };
    const cancel = () => finish(null);
    btnCancel.onclick = cancel;
    btnClose.onclick = cancel;
    ov.onclick = (e) => { if (e.target === ov) cancel(); };

    ov.classList.add("show");
    ov.setAttribute("aria-hidden","false");
    window.addEventListener("keydown", onKey);

    setTimeout(() => input.focus(), 0);
  });
}

  window.openPresetNameOverlay = openPresetNameOverlay;



function indexFiles(files){
    const byRel = new Map();
    const byName = new Map();      // exact filename -> File
    const byNorm = new Map();      // normalized filename -> [File,...] (allow reuse)

    const normKey = (name) => {
      const s0 = (name || "").toString().toLowerCase().trim();
      if (!s0) return "";
      // keep only the filename part
      const parts = s0.replace(/\\/g,"/").split("/");
      const fname = parts[parts.length-1] || s0;

      const ext = (fname.includes(".") ? fname.split(".").pop() : "");
      let base = fname.replace(/\.[^/.]+$/,"");

      // common patterns from freesound-style downloads / export tools
      base = base.replace(/^\d+__+/,"");                 // drop leading numeric id + '__'
      base = base.replace(/\s+audio\s+extracted$/,"");  // drop trailing ' Audio Extracted'
      base = base.replace(/__+/g,"_");                    // collapse __

      // strip all non-alphanumerics for robust matching
      base = base.replace(/[^a-z0-9]+/g,"");
      if (!base) return "";
      return base + (ext ? ("."+ext) : "");
    };

    for (const f of files){
      const rel = (f.webkitRelativePath || f._relPath || "").toLowerCase();
      if (rel) byRel.set(rel, f);

      const key = (f.name || "").toLowerCase();
      if (key && !byName.has(key)) byName.set(key, f);

      const nk = normKey(f.name || "");
      if (nk){
        if (!byNorm.has(nk)) byNorm.set(nk, []);
        byNorm.get(nk).push(f);
      }
    }
    return {byRel, byName, byNorm, normKey};
  }

  function resolveFile(ref, index){
    if (!ref) return null;

    // 1) exact relPath match (most reliable)
    const rel = (ref.relPath || ref.path || "").toString().toLowerCase();
    if (rel && index.byRel.has(rel)) return index.byRel.get(rel);

    // 2) exact filename match
    const fname = (ref.fileName || ref.name || ref.file || "").toString().toLowerCase();
    if (fname && index.byName.has(fname)) return index.byName.get(fname);

    // 3) normalized filename match (robust to id prefixes / '__' / 'Audio Extracted' suffix)
    const nk = index.normKey ? index.normKey(fname) : "";
    if (nk && index.byNorm && index.byNorm.has(nk) && index.byNorm.get(nk).length){
      return index.byNorm.get(nk)[0]; // allow reuse across multiple cells
    }
    return null;
  }

  async function importPresetFlow(preset){
    if (!preset || typeof preset !== "object") throw new Error("Invalid preset JSON");

    // Apply global timing controls if present
    if (preset.tempo && typeof preset.tempo === "object"){
      if (typeof preset.tempo.tempoMode === "boolean") tempoModeEl.checked = preset.tempo.tempoMode;
      if (typeof preset.tempo.bpm === "number") bpmEl.value = String(preset.tempo.bpm);
      if (typeof preset.tempo.beatsPerCell === "number") beatsPerCellEl.value = String(preset.tempo.beatsPerCell);
      onTimingChanged();
    }

    // Apply column names (prefer preset.colNames, fallback to preset.columns[].name)
const applyColName = (c, name) => {
  if (typeof name !== "string") return;
  state.colNames[c] = name;
  const el = document.getElementById(`colName-${c}`);
  if (el) el.value = name;
};

if (Array.isArray(preset.colNames)){
  for (let c=0;c<COLS;c++){
    applyColName(c, preset.colNames[c]);
  }
} else if (Array.isArray(preset.columns)){
  for (let c=0;c<COLS;c++){
    const col = preset.columns[c];
    if (col && typeof col.name === "string"){
      applyColName(c, col.name);
    }
  }
}

    // Apply cell names (optional)
const applyCellName = (c, r, name) => {
  if (typeof name !== 'string') return;
  if (!state.cellNames) state.cellNames = Array.from({length: COLS}, (_, cc) => Array.from({length: ROWS}, (_, rr) => `C${rr+1}`));
  state.cellNames[c][r] = name;
  // If this cell is currently selected, reflect immediately in the inspector field
  const sel = state.selected && state.selected.has ? state.selected : null;
  if (sel && sel.col === c && sel.row === r){
    try{ updateInspector(); }catch(_){ }
  }
};

if (Array.isArray(preset.cellNames)){
  for (let c=0;c<COLS;c++){
    const colArr = preset.cellNames[c];
    if (!Array.isArray(colArr)) continue;
    for (let r=0;r<ROWS;r++){
      applyCellName(c, r, colArr[r]);
    }
  }
}


    const files = await requestSampleFolder(preset);
    if (!files || !files.length){
      setStatus("No files received from the folder picker. If you are running via file://, try opening the app via http://localhost (or another local web server) and retry.", "bad");
      return;
    }
    const idx = indexFiles(files);

    let loaded = 0, missing = 0;

    // Two-pass: handle full-column splits if detected
    const splitPlan = new Array(COLS).fill(null); // {ref, cells} when a column was Load+Slice-sourced
    if (Array.isArray(preset.columns)){
      for (let c=0;c<COLS;c++){
        const col = preset.columns[c];
        if (!col || !Array.isArray(col.cells) || col.cells.length !== ROWS) continue;
        const origins = col.cells.map(x => x?.origin).filter(Boolean);
        const allSplit = origins.length === ROWS && origins.every(o => o.type === "split");
        if (allSplit){
          const o0 = origins[0];
          const same = origins.every(o => (o.fileName||"") === (o0.fileName||"") && (o.relPath||"") === (o0.relPath||""));
          if (same){
            splitPlan[c] = { ref: o0, cells: col.cells };
          }
        }
      }
    }

    // Execute split columns first (preset-aware slice windows)
    for (let c=0;c<COLS;c++){
      if (!splitPlan[c]) continue;
      const plan = splitPlan[c];
      const ref = plan.ref;
      const file = resolveFile(ref, idx);
      if (!file){
        missing += ROWS;
        continue;
      }
      await loadFileSliceIntoColumnFromPreset(c, file, plan.cells);
      loaded += ROWS;
    }

    // Now per-cell loads + settings
    for (let c=0;c<COLS;c++){
      const col = preset.columns?.[c];
      const cells = col?.cells;
      if (!Array.isArray(cells)) continue;

      for (let r=0;r<ROWS;r++){
        const cellP = cells[r];
        const cell = state.cells[c][r];
        if (!cellP) continue;

        // apply settings
        if (cellP.settings && typeof cellP.settings === "object"){
          cell.settings = { ...cell.settings, ...cellP.settings };
        }

        // apply wave selection metadata (optional)
        if (typeof cellP.selStartFrames === "number") cell.selStartFrames = cellP.selStartFrames;
        if (typeof cellP.selLenFrames === "number") cell.selLenFrames = cellP.selLenFrames;
        // NOTE: do NOT force sourceKey from preset; it is regenerated when loading files

        // if already loaded via splitPlan, skip file load
        if (splitPlan[c]){
          updateCellUI(c,r);
          continue;
        }

        const ref = cellP.origin || { fileName: cellP.fileName || cellP.name, relPath: cellP.relPath || "" };
        const file = resolveFile(ref, idx);
        if (!file){
          missing++;
          // keep name for user
          if (cellP.name) cell.name = String(cellP.name);
          cell.origin = ref;
          updateCellUI(c,r);
          continue;
        }
        await loadFileIntoCell(c, r, file, { silent: true });
        loaded++;
      }
      updateColUI(c);
    }

    updateInspector();
    setStatus(`Preset loaded. ${loaded} relinked, ${missing} missing.`, missing ? "warn" : "good");
    if (missing){
      toast("Some samples could not be found. Keep the same filenames (or restore the same folder structure) to relink.", 4200);
    }
  }

  async function importPreset(){
    presetFileInput.value = "";
    presetFileInput.onchange = async () => {
      const f = presetFileInput.files && presetFileInput.files[0];
      if (!f) return;
      try{
        const txt = await f.text();
        const preset = JSON.parse(txt);
        await importPresetFlow(preset);
      }catch(err){
        // If the user cancels the folder picker, do not treat it as an error.
        if (err && (err.name === "AbortError" || err.code === 20)){
          setStatus("Preset import cancelled.", "warn");
          return;
        }
        console.error(err);
        setStatus("Preset import failed: " + (err?.message || String(err)), "bad");
      }
    };
    presetFileInput.click();
  }

  if (importPresetBtn){
    importPresetBtn.addEventListener("click", () => importPreset());
  }
  }
  if (helpCloseBtnEl){
    helpCloseBtnEl.addEventListener("click", () => closeHelp());
  }
  if (helpOverlayEl){
    helpOverlayEl.addEventListener("click", (e) => {
      if (e.target === helpOverlayEl) closeHelp();
    });
  }

  function isAudioFile(file){
    if (!file) return false;
    if (file.type && file.type.startsWith('audio/')) return true;
    const ext = (file.name || '').split('.').pop().toLowerCase();
    return ['wav','mp3','ogg','flac','aif','aiff','m4a','aac','opus'].includes(ext);
  }

  function shuffleInPlace(arr){
    for (let i = arr.length - 1; i > 0; i--){
      const j = (Math.random() * (i + 1)) | 0;
      const t = arr[i];
      arr[i] = arr[j];
      arr[j] = t;
    }
    return arr;
  }

  async function randomFill64FromFiles(files){
    // Stability: reset engines before heavy batch load
    hardResetEngines();
    try{ updateRandom64FilterIndicator(); }catch(_){}
    files = applyRandomFilters(files);
    const all = Array.from(files || []);
    const pool = all.filter(isAudioFile);
    const nonAudio = all.length - pool.length;
    const MAX_RANDOM_SEC = 60; // Random 64 only uses files shorter than this (seconds) // Only use files shorter than this (seconds) for Random 64

    if (!pool.length){
      toast(`No audio files found in that selection. (${nonAudio} non-audio items)`, 3200);
      return;
    }

    const totalCells = COLS * ROWS;
    let chosen = [];

    if (pool.length >= totalCells){
      chosen = shuffleInPlace(pool.slice()).slice(0, totalCells);
    } else {
      // Not enough unique files: sample with replacement
      for (let i=0; i<totalCells; i++){
        chosen.push(pool[(Math.random() * pool.length) | 0]);
      }
      toast(`Only ${pool.length} file(s) available — reusing files to fill 64 cells.`, 2800);
    }

    const cells = [];
    for (let c=0;c<COLS;c++) for (let r=0;r<ROWS;r++) cells.push({c,r});
    shuffleInPlace(cells);

    toast(`Random fill: loading 64 cells from ${pool.length} file(s) (≤ ${MAX_RANDOM_SEC}s)…`, 1800);

    // Sequential load for stability (64 decodes can be heavy)
    let failCount = 0;
    let lastFail = "";
    for (let i=0; i<cells.length; i++){
      const {c, r} = cells[i];

      // Try the intended file first; if decode fails, retry with other random files.
      let ok = false;
      let attemptFile = chosen[i];
      for (let attempt=0; attempt<8; attempt++){
        // Skip very long files BEFORE decoding/loading into a cell.
        const dur = await getFileDurationSec(attemptFile);
        if (dur != null && dur > MAX_RANDOM_SEC){
          // pick another random file from pool
          attemptFile = pool[(Math.random() * pool.length) | 0];
          continue;
        }

        try{
          await loadFileIntoCell(c, r, attemptFile, { silent: true });
          ok = true;
          break;
        }catch(err){
          failCount++;
          lastFail = (attemptFile && attemptFile.name) ? attemptFile.name : String(attemptFile || "");
          console.warn("Random 64: decode/load failed for", lastFail, err);

          // pick another random file from pool and try again
          attemptFile = pool[(Math.random() * pool.length) | 0];
        }
      }

      if (!ok){
        // If still not ok after retries, clear this cell so UI is consistent.
        clearCell(c, r);
      }

      if (i === 31) toast('Random fill: halfway (32/64)…', 1400);
    

      // Yield periodically to keep Safari responsive
      if ((i % 2) === 1) await new Promise(requestAnimationFrame);
    }

    updateAllUIBatched(6);
    if (failCount){
      toast(`Random fill complete with ${failCount} decode/load failure(s). Last: ${lastFail || "?"}`, 4200);
    } else {
      toast('Random fill complete.', 2200);
    }
  }

  // Random 64 via folder picker
  random64Btn?.addEventListener('click', (e) => {
    // Shift+Click: configure filename include/exclude filters (comma separated)
    if (e && e.shiftKey){
      try{
        const fn = window.openRandom64FilterOverlay || openRandom64FilterOverlay;
        if (typeof fn !== "function"){
          toast("Filter UI unavailable in this build.", 2800);
          return;
        }
        fn().then((res) => {
          if (!res) return;
          const {inc, exc} = res;
          setFilterList(FILTER_KEY_INCLUDE, inc);
          setFilterList(FILTER_KEY_EXCLUDE, exc);
          const incList = getFilterList(FILTER_KEY_INCLUDE);
          const excList = getFilterList(FILTER_KEY_EXCLUDE);
          updateRandom64FilterIndicator();
          toast(`Random 64 filters set. include=${incList.length}, exclude=${excList.length}`, 2200);
        }).catch((err) => {
          console.error(err);
          toast("Filter dialog failed: " + (err?.message || String(err)), 3600);
        });
      }catch(err){
        console.error(err);
        toast("Filter dialog failed: " + (err?.message || String(err)), 3600);
      }
      return;
    }

    folderInput.value = '';
    folderInput.click();
  });

  folderInput?.addEventListener('change', async () => {
    const files = folderInput.files;
    if (!files || !files.length) return;
    await randomFill64FromFiles(files);
    folderInput.value = '';
  });

  // Drag & drop onto the Random 64 button (drop a bunch of files)
  random64Btn?.addEventListener('dragover', (e) => { e.preventDefault(); random64Btn.classList.add('dragover'); });
  random64Btn?.addEventListener('dragleave', () => random64Btn.classList.remove('dragover'));
  random64Btn?.addEventListener('drop', async (e) => {
    e.preventDefault();
    random64Btn.classList.remove('dragover');
    const files = e.dataTransfer?.files;
    if (!files || !files.length){
      toast('Nothing to drop. Drop audio files (or pick a folder).', 2600);
      return;
    }
    await randomFill64FromFiles(files);
  });

  clearAllBtn.addEventListener("click", () => clearAll());

  window.addEventListener("keydown", (e) => {
    // Cmd/Ctrl+Z (undo), Cmd/Ctrl+Shift+Z / Ctrl+Y (redo)
    const isMac = navigator.platform.toUpperCase().includes("MAC");
    const mod = isMac ? e.metaKey : e.ctrlKey;
    if (mod && (e.key === "z" || e.key === "Z")){
      e.preventDefault();
      if (e.shiftKey) doRedo();
      else doUndo();
      return;
    }
    if (mod && (e.key === "y" || e.key === "Y")){
      e.preventDefault();
      doRedo();
      return;
    }

        // If Wave Editor is open, it owns keyboard controls (space/arrows)
    if (window.waveEditor && window.waveEditor.open){
      if (e.key === " " || e.code === "Space" || e.key === "ArrowLeft" || e.key === "ArrowRight"){
        return;
      }
    }

    
    // SPLIT_NUDGE_KEYS: when Split Editor is open, arrow keys nudge the active slice (instead of cell navigation)
    const splitOpen = (splitOverlayEl && splitOverlayEl.style.display !== "none");

    if (splitOpen && e.key === "Escape") {
      try{
        const magVisible = (typeof _mag !== "undefined" && _mag && _mag.el && _mag.el.style.display !== "none");
        if (magVisible){
          magHide();
        } else {
          splitClose();
        }
      }catch(_e){
        try{ splitClose(); }catch(__){}
      }
      e.preventDefault();
      e.stopPropagation();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      return;
    }
    if (splitOpen && (e.key==="ArrowLeft" || e.key==="ArrowRight" || e.key==="ArrowUp" || e.key==="ArrowDown")){
      // Debug toast to confirm key is captured
      const fine = e.altKey ? 16 : 0;          // ~1.3ms at 48k
      const coarse = e.shiftKey ? 1024 : 0;     // ~42.7ms at 48k
      const baseStep = 128;                     // ~5.3ms at 48k
      const step = fine || coarse || baseStep;
      const dir = (e.key==="ArrowLeft" || e.key==="ArrowUp") ? -1 : 1;
      const mode = ((_mag && _mag.on && (_mag.edge==='L' || _mag.edge==='R')) ? _mag.edge : (waveEditor.nudgeEdge||'C'));

      e.preventDefault();
      e.stopPropagation();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();

      splitNudgeActive(dir * step, mode);
      // keep magnifier selection in sync if it's open
      try{
        if (_mag && _mag.on){
          const st = splitGetState(splitCol);
          const b = st.blocks[splitActiveIdx|0];
          if (b) magUpdate({selStart:(b.s|0), selEnd:((b.s|0)+(b.l|0))});
        }
      }catch(_){}
      return;
    }

// Arrow-key navigation between cells (only when no overlay is open and not typing in a field)
    if (!mod && !e.altKey){
      const ae = document.activeElement;
      const tag = ae ? ae.tagName : "";
      const typing = tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || (ae && ae.isContentEditable);
      const overlayOpen = !!Array.from(document.querySelectorAll('.overlay.show')).find(el => el.style.display !== 'none' && el.getAttribute('aria-hidden') !== 'true');
      // Enter on a selected cell focuses the Cell name field for fast naming
      if (!typing && !overlayOpen && e.key === 'Enter' && state && state.selected && state.selected.has && cellNameEl){
        e.preventDefault();
        try{ cellNameEl.focus(); cellNameEl.select(); }catch(_){}
        return;
      }
    // Space in Split Editor: play/stop focused slice
    if (e.code==="Space" && splitOverlayEl && splitOverlayEl.style.display!=="none"){
      e.preventDefault();
      splitPlayActiveSlice();
      return;
    }
      if (!typing && !overlayOpen && state && state.selected){
        let dc = 0, dr = 0;
        if (e.key === "ArrowLeft") dc = -1;
        else if (e.key === "ArrowRight") dc = 1;
        else if (e.key === "ArrowUp") dr = -1;
        else if (e.key === "ArrowDown") dr = 1;

        if (dc || dr){
          e.preventDefault();
          let c = state.selected.has ? state.selected.col : 0;
          let r = state.selected.has ? state.selected.row : 0;
          c = (c + dc + COLS) % COLS;
          r = (r + dr + ROWS) % ROWS;
          setSelected(c, r);
          return;
        }
      }
    }


if (e.key === "Escape"){
      if (helpOverlayEl && helpOverlayEl.classList.contains("show")){ closeHelp(); e.preventDefault(); return; }
      stopPlayback();
    }
    if (e.key === " "){
      // space: play selected
      // If a button (e.g. Load) still has focus, drop it so Space doesn't show focus ring
      try{ const ae=document.activeElement; if (ae && ae.tagName==="BUTTON") ae.blur(); }catch(_e){}
      if (state.selected.has){
        e.preventDefault();
        const {col,row} = state.selected;
        const cellEl = colsEl.querySelector(`.cell[data-col="${col}"][data-row="${row}"]`);
        playCell(col,row, cellEl);
      }
    }
    if (e.key === "Delete" || e.key === "Backspace"){
      if (state.selected.has){
        clearCell(state.selected.col, state.selected.row);
      }
    }
  });

  // When tempo settings change, update labels and invalidate caches (targetFrames changes)
  function onTimingChanged(){
    updateSpecLine();
    updateAllTimeLabels();

    // invalidate caches because targetFrames may change
    for (let c=0;c<COLS;c++){
      for (let r=0;r<ROWS;r++){
        state.cells[c][r].cache = { key:"", L:null, R:null, frames:0 };
      }
    }

    updateInspector();
    markAllWavesDirty();
  }

  tempoModeEl.addEventListener("change", onTimingChanged);
  bpmEl.addEventListener("input", () => { if (tempoModeEl.checked) onTimingChanged(); });
  beatsPerCellEl.addEventListener("input", () => { if (tempoModeEl.checked) onTimingChanged(); });

  // File picker
  fileInput.addEventListener("change", async () => {
    const files = Array.from(fileInput.files || []);
    if (!files.length) return;

    const p = state.pick;
    state.pick = { kind:null, col:null, row:null };

    try{
      if (p.kind === "colmulti"){
        await loadFilesIntoColumnCells(p.col, files);
      } else {
        toast("Loading…");
        const file = files[0];
        if (p.kind === "cell"){
          await loadFileIntoCell(p.col, p.row, file);
        } else if (p.kind === "split"){
          await loadFileSplitIntoColumn(p.col, file);
        } else if (p.kind === "splitEditor"){
          const col = p.col;
          // Decode into sourceStore only
          const {left, right, name} = await decodeFileToStereo48k(file);
          const durSec = left.length / SR;
          if (durSec > MAX_SPLIT_LOAD_SEC) {
            toast(`Sample too long for Load+Slice (${durSec.toFixed(1)}s). Max is ${MAX_SPLIT_LOAD_SEC}s.`);
            return;
          }
          const key = getSourceKeyFromFile(file, name);
          ensureSourceInStore(key, left, right, name);
          const st = splitGetState(col);
          st.sourceKey = key;
          st.undo = [];
          // init blocks
          splitCol = col;
          splitAutoTile();
          splitUndoBtnEl && (splitUndoBtnEl.disabled = true);
          splitHintEl && (splitHintEl.textContent = "Drag or resize the 8 selection blocks. Each block is limited to the max cell length.");
          splitScheduleDraw();
          // open the split editor after loading the sample
          splitOpen(col);
        }
        updateInspector();
      }
    } catch (err){
      console.error(err);
      toast("Load error (unsupported format?)", 3000);
    } finally {
      fileInput.value = "";
      fileInput.multiple = false;
    }
  });
  // ====== Init ======
  updateSpecLine();
  
  renderReleaseNotes();
  // Fill version text (avoids manual sync in multiple places)
  const cEl = document.getElementById("copyrightText");
  if (cEl) cEl.textContent = `© 2026 Patronix · v${APP_VERSION}`;
  const aboutEl = document.getElementById("aboutBadge");
  if (aboutEl){
    aboutEl.textContent = `v${APP_VERSION}`;
    const bd = (typeof APP_BUILD_DATE !== "undefined" && APP_BUILD_DATE) ? APP_BUILD_DATE : "";
    aboutEl.title = bd ? (`Version ${APP_VERSION} · Build ${bd}`) : (`Version ${APP_VERSION}`);
    aboutEl.addEventListener("click", (e)=>{ e.preventDefault(); try{ document.getElementById("helpBtn")?.click(); }catch(_){} });
    aboutEl.style.cursor = "pointer";
  }

  initNameTemplateHistory();

  build();

  window.addEventListener("DOMContentLoaded", () => {
    try{ waveAttachHandlers(); }catch(e){ showFatal(e); }
    try{ splitAttachHandlers(); }catch(e){ showFatal(e); }
    try{ updateRandom64FilterIndicator(); }catch(e){}
  });
  setupWaveObserver();
  onTimingChanged();

})();

// === Handle Magnifier (Phase 1) ===
const _mag = {
  lastYWave:null,
  lastYSplit:null,
  srcTag:"",
  zoomMul: 1,
  autoNorm: false,
  baseHalfWinFrames: 0
,
 on:false, src:null, total:0, selStart:0, selEnd:0, edge:"R", halfWinFrames:0, el:null, cv:null, ctx:null, lbl:null, _raf:0 };
const MAG_DENSITY_THRESH = 900; // frames-per-pixel threshold to auto-show magnifier

function magClampY(y){
  try{
    const pad = 12;
    const h = _mag.el ? _mag.el.offsetHeight : 180;
    // Because we draw above the pointer (translate -115%) we keep the pointer far enough from the top.
    let minY = pad + h;
    let maxY = (window.innerHeight - pad);

    // In the Slice Editor, keep the magnifier inside the big waveform area so it never covers the info row.
    try{
      if ((_mag.srcTag||"") === "split"){
        const wrap = document.getElementById("splitBigWrap");
        if (wrap && wrap.getBoundingClientRect){
          const r = wrap.getBoundingClientRect();
          // Keep pointer anchor within the canvas area.
          minY = Math.max(minY, Math.floor(r.top + pad + h));
          maxY = Math.min(maxY, Math.floor(r.bottom - pad));
        }
      }
    }catch(_e){}

    return magClamp(y|0, minY, maxY);
  }catch(_){ return y|0; }
}

function magClampX(x){
  try{
    const pad = 12;
    const w = _mag.el ? _mag.el.offsetWidth : 420;
    const minX = pad + Math.floor(w/2);
    const maxX = (window.innerWidth - pad) - Math.floor(w/2);
    return magClamp(x|0, minX, maxX);
  }catch(_){ return x|0; }
}

function magClamp(v,a,b){ return v<a ? a : (v>b ? b : v); }

function magEdgeFromClick(px, W, xSelL, xSelR){
  // px is click position in canvas coords [0..W]
  const pad = Math.max(8, Math.min(24, Math.floor(W*0.03)));
  if (Math.abs(px - xSelL) <= pad) return "L";
  if (Math.abs(px - xSelR) <= pad) return "R";
  return "C";
}

function magInit(){
  if (_mag.el) return;
  _mag.el = document.getElementById("tcmMag");
  try{ _mag.el.style.zIndex = "36000"; }catch(_e){} 
  _mag.cv = document.getElementById("tcmMagCv");
  _mag.ctx = _mag.cv.getContext("2d");
  _mag.lbl = document.getElementById("tcmMagLbl");
  _mag.lblTxt = document.getElementById("tcmMagLblTxt");
  _mag.zInd = document.getElementById("zIndMag");
}

function magRenderZIndicators(){
  try{
    const on = !!(_mag && _mag.on);
    const active = on && !!_mag.autoNorm;
    const ids = ["zIndMag","zIndWave"];
    for (const id of ids){
      const el = document.getElementById(id);
      if (!el) continue;
      el.classList.toggle("armed", on);
      el.classList.toggle("active", active);
    }
  }catch(_){}
}

function magSetLabelText(t){
  try{
    if (_mag.lblTxt) _mag.lblTxt.textContent = t || "";
    else if (_mag.lbl) _mag.lbl.textContent = t || "";
  }catch(_){}
}

function magShow({src, total, selStart, selEnd, edge, x, y, label, centerPos, tag}){
  magInit();
  _mag.on = true;
  _mag.srcTag = tag || _mag.srcTag || "";
  // Wave editor uses a smaller magnifier so it doesn't dominate the UI
  try{
    const isSmall = (_mag.srcTag === "wave" || _mag.srcTag === "split");
    if (_mag.el) _mag.el.classList.toggle("magWave", isSmall);
    if (_mag.cv){
      _mag.cv.width  = isSmall ? 340 : 420;
      _mag.cv.height = isSmall ? 160 : 200;
    }
  }catch(_){ }
_mag.src = src;
  _mag.total = (total|0) || (src?.L?.length|0) || 0;
  _mag.selStart = selStart|0;
  _mag.selEnd = selEnd|0;
  _mag.edge = edge || "R";
  _mag.centerPos = (typeof centerPos === "number") ? (centerPos|0) : null;
  // Higher zoom: smaller window around the active edge
  const t = Math.max(1, _mag.total|0);
  const half = Math.max(320, Math.min(Math.floor(t*0.005), 6500)); // ~2.5% of file, clamped
  _mag.baseHalfWinFrames = half;
  _mag.halfWinFrames = Math.max(8, Math.round(_mag.baseHalfWinFrames / Math.max(0.25, (_mag.zoomMul||1))));
  _mag.el.style.display = "block";
  _mag.el.classList.add("tcmMagOn");
  _mag.labelBase = (label || "");
  magSetLabelText(_mag.labelBase);
  magRenderZIndicators();
  magSetPos(x, y);
  magRequestDraw();
}

function magHide(){
  if (!_mag.el) return;
  _mag.on = false;
  _mag.src = null;
  magRenderZIndicators();
  if (_mag._raf){
    try{ cancelAnimationFrame(_mag._raf); }catch(_){}
    _mag._raf = 0;
  }
  _mag.el.style.display = "none";
}

function magSetPos(anchorX, mouseY){
  if (!_mag.on || !_mag.el) return;
  const xi = Number.isFinite(anchorX) ? anchorX : null;
  let yi = Number.isFinite(mouseY) ? mouseY : null;

  // Remember vertical position per editor; X is always anchored by caller.
  const tag = _mag.srcTag || "";
  if (yi === null){
    yi = (tag==="wave") ? _mag.lastYWave : (tag==="split" ? _mag.lastYSplit : null);
  }
  if (yi !== null){
    // Wave editor: keep the magnifier on-screen.
    // Split/Slice editor: do NOT clamp Y; clamping makes the magnifier "stick" over the selection.
    if (tag === "wave") yi = magClampY(yi);
    if (tag==="wave") _mag.lastYWave = yi;
    if (tag==="split") _mag.lastYSplit = yi;
  }

  if (xi !== null){
    const xc = magClampX(xi);
    _mag.el.style.left = (xc|0) + "px";
  }
  if (yi !== null) _mag.el.style.top  = (yi|0) + "px";
}

function magMove(x, y){
  if (!_mag.on || !_mag.el) return;
  _mag.el.style.left = (x|0) + "px";
  _mag.el.style.top  = (y|0) + "px";
}

function magUpdate({selStart, selEnd, x, y, label}){
  if (!_mag.on) return;
  if (typeof selStart === "number") _mag.selStart = selStart|0;
  if (typeof selEnd === "number") _mag.selEnd = selEnd|0;
  if (label) magSetLabelText(label);
  if (typeof x === "number" && typeof y === "number") magSetPos(x, y);
  magRequestDraw();
}

function magRequestDraw(){
  if (!_mag.on) return;
  if (_mag._raf) return;
  _mag._raf = requestAnimationFrame(() => {
    _mag._raf = 0;
    magDraw();
  });
}

function magDraw(){
  if (!_mag.on || !_mag.ctx || !_mag.src || !_mag.src.L) return;
  const ctx = _mag.ctx;
  const W = _mag.cv.width|0, H = _mag.cv.height|0;

  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "rgba(0,0,0,0.25)";
  ctx.fillRect(0,0,W,H);

  const L = _mag.src.L;
  const R = _mag.src.R || _mag.src.L;
  const total = _mag.total|0;
    const edgePos = (_mag.edge === "L") ? (_mag.selStart|0) : (_mag.edge === "R" ? (_mag.selEnd|0) : ( (_mag.centerPos!=null) ? (_mag.centerPos|0) : (((_mag.selStart|0)+(_mag.selEnd|0))>>1) ));
  const half = _mag.halfWinFrames|0;

  // Keep zoom factor consistent even near file start/end by shifting the window instead of shrinking it
  const targetLen = Math.max(1, Math.min(total, (half*2)|0));
  let winA = (edgePos - half)|0;
  winA = magClamp(winA, 0, Math.max(0, total - targetLen));
  let winB = (winA + targetLen)|0;
  const winLen = Math.max(1, winB - winA);

  // Optional auto-normalize (toggle with Z) so peaks fill the magnifier
  let peak = 0;
  if (_mag.autoNorm){
    const spanAll = Math.max(1, winB - winA);
    const stepP = Math.max(1, Math.floor(spanAll / 6000));
    for (let i=winA; i<winB; i+=stepP){
      const aL = Math.abs(L[i]||0);
      const aR = Math.abs(R[i]||0);
      const m = (aL>aR)?aL:aR;
      if (m>peak) peak=m;
    }
    if (!Number.isFinite(peak) || peak < 1e-6) peak = 0;
  }
  const normScale = (_mag.autoNorm && peak>0) ? (1/peak) : 1;

  ctx.strokeStyle = "rgba(255,255,255,0.88)";
  ctx.lineWidth = 1;

  const mid = H/2;
  for (let x=0; x<W; x++){
    const a = winA + Math.floor((x / W) * winLen);
    const b = winA + Math.floor(((x+1) / W) * winLen);
    const bb = Math.max(a+1, b);
    const span = Math.max(1, bb - a);

    // Max-abs envelope per pixel (captures transients)
    let mxAbs = 0;
    // Keep worst-case work bounded while still being much more "peaky"
    const step = Math.max(1, Math.floor(span / 2048));
    for (let i=a; i<bb; i+=step){
      const vL = L[i] || 0;
      const vR = R[i] || 0;
      const aL = Math.abs(vL);
      const aR = Math.abs(vR);
      const m = (aL > aR) ? aL : aR;
      if (m > mxAbs) mxAbs = m;
    }

    const amp = (mxAbs * normScale) * (mid * 0.995);
    const y1 = mid - amp;
    const y2 = mid + amp;

    ctx.beginPath();
    ctx.moveTo(x+0.5, y1);
    ctx.lineTo(x+0.5, y2);
    ctx.stroke();
  }

  const xSelL = Math.round(((_mag.selStart - winA) / winLen) * W);
  const xSelR = Math.round(((_mag.selEnd   - winA) / winLen) * W);
  const xl = magClamp(Math.min(xSelL, xSelR), 0, W);
  const xr = magClamp(Math.max(xSelL, xSelR), 0, W);

  ctx.fillStyle = "rgba(120,200,120,0.08)";
  ctx.fillRect(xl, 0, Math.max(0, xr-xl), H);

  ctx.strokeStyle = "rgba(255,255,255,0.95)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(xl+0.5, 0); ctx.lineTo(xl+0.5, H);
  ctx.moveTo(xr+0.5, 0); ctx.lineTo(xr+0.5, H);
  ctx.stroke();

  const xEdge = (_mag.edge === "L") ? xl : (_mag.edge === "R" ? xr : Math.round((xl+xr)/2));
  ctx.strokeStyle = "rgba(255,220,120,0.95)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(xEdge+0.5, 0); ctx.lineTo(xEdge+0.5, H);
  ctx.stroke();

  ctx.strokeStyle = "rgba(255,255,255,0.10)";
  ctx.lineWidth = 1;
  ctx.strokeRect(0.5,0.5,W-1,H-1);
}

document.addEventListener("keydown", (ev) => {
  if (ev.key !== "Escape") return;
  // Don't auto-hide the magnifier here while an editor is open; editors handle Esc themselves.
  try{
    if (typeof waveEditor !== "undefined" && waveEditor && waveEditor.open) return;
  }catch(_e){}
  magHide();
});

function magAnchorWave(total, selStart, selEnd){
  try{
    const rect = waveBigEl.getBoundingClientRect();
    const t = Math.max(1, total|0);
    const frac = ((selStart + selEnd) * 0.5) / t;
    return { x: rect.left + frac * rect.width, y: rect.top + rect.height*0.5 };
  }catch(_){ return null; }
}
function magAnchorSplit(total, bb){
  try{
    const rect = splitBigEl.getBoundingClientRect();
    const t = Math.max(1, total|0);
    const frac = (bb.s + bb.l*0.5) / t;
    return { x: rect.left + frac * rect.width, y: rect.top + rect.height*0.5 };
  }catch(_){ return null; }
}


function magSetZoomMul(newMul){
  _mag.zoomMul = magClamp(newMul, 0.25, 16);
  if (_mag.baseHalfWinFrames>0){
    _mag.halfWinFrames = Math.max(8, Math.round(_mag.baseHalfWinFrames / Math.max(0.25, _mag.zoomMul)));
  }
  try{ magDraw(); }catch(_){}
}

// === /Handle Magnifier ===


// Magnifier keys: +/- zoom, Z toggles Auto-Norm (when magnifier is visible)
window.addEventListener("keydown", (ev)=>{
  try{
    if (!_mag || !_mag.on) return;

    // don't steal typing in inputs, and don't interfere with Cmd/Ctrl+Z undo
    const t = ev.target;
    if (t && (t.tagName==="INPUT" || t.tagName==="TEXTAREA" || t.isContentEditable)) return;
    if (ev.ctrlKey || ev.metaKey) return;

    const k = ev.key;
    if (k==="+" || k==="="){
      ev.preventDefault();
      magSetZoomMul((_mag.zoomMul||1) * 1.35);
      magRenderZIndicators();
      magRequestDraw();
    } else if (k==="-" || k==="_"){
      ev.preventDefault();
      magSetZoomMul((_mag.zoomMul||1) / 1.35);
      magRenderZIndicators();
      magRequestDraw();
    } else if (k==="z" || k==="Z"){
      // Z always allowed while magnifier is visible
      ev.preventDefault();
      ev.stopPropagation();
      if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();
      try{ tcmStealKeys(); }catch(_){ }

      _mag.autoNorm = !_mag.autoNorm;
      magRenderZIndicators();
      magRequestDraw();
    }
  }catch(_){ }
}, {capture:true});

</script>

  


  <!-- Wave Editor Overlay (v2.5.24 foundation) -->
  <div class="overlay" id="waveOverlay" aria-hidden="true" style="display:none;">
    <div class="helpPanel wavePanel">
      <div class="helpHead">
        <div class="helpTitle" id="waveTitle">Wave Editor<span id="zIndWave" class="z-indicator" title="Z: Auto-Norm">Z</span></div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button class="helpClose" type="button" id="wavePlaySelBtn" title="Play current selection">Play sel</button>
          <button class="helpClose" type="button" id="wavePlayFullBtn" title="Play full source">Play full</button>
          <button class="helpClose" type="button" id="waveSnapBtn" title="Snap apply to zero-crossing">Snap: on</button>
                    <button class="helpClose" type="button" id="waveTrimBtn" title="Trim source to selection (undo available)">Trim</button>
          <button class="helpClose" type="button" id="waveUndoBtn" title="Undo trim (Ctrl/Cmd+Z)">Undo</button>
<button class="helpClose" type="button" id="waveApplyBtn" title="Apply selection to the cell">Apply</button>
          <button class="helpClose" type="button" id="waveResetBtn" title="Reset selection to full cell length">Reset</button>
          <button class="helpClose" type="button" id="waveCloseBtn" title="Close">✕</button>
        </div>
      </div>
      <div class="helpBody">
        <div class="waveEditorWrap">
          <div class="waveCanvasWrap">
            <canvas id="waveBig" width="900" height="220" class="waveBig"></canvas>
            <div class="waveScissorIcon" title="Trim selection">✂</div>
          </div>
          <div class="waveEditorMeta">
            <div class="kv"><span class="k">Start</span><span class="v" id="waveSelStart">—</span></div>
            <div class="kv"><span class="k">Length</span><span class="v" id="waveSelLen">—</span></div>
            <div class="kv"><span class="k">Source</span><span class="v" id="waveSrcName">—</span></div>
          </div>
          <div class="waveEditorHint">
            Drag the selection window. Click inside to move; click outside jumps (zoom closes). Apply makes this selection the cell audio (used for playback + export). If the zoom window is visible: Z toggles Auto-Norm, +/- zooms, Esc (or clicking outside selection) hides it. Click outside the selection hides the zoom window.
          </div>

          <div class="waveShortcuts">
            <div class="waveShortcutsTitle">Shortcuts</div>
            <ul class="waveShortcutsList">
              <li><b>Space</b> — play selection</li>
              <li><b>← / →</b> — nudge selection</li>
              <li><b>L</b> / <b>M</b> / <b>R</b> — choose Left / Middle / Right control</li>
              <li><b>Shift</b> + ← / → — coarse nudge</li>
              <li><b>Alt/Option</b> + ← / → — fine nudge</li>
              <li><b>+</b> / <b>-</b> — zoom window (when visible)</li>
              <li><b>Z</b> — auto-normalize (when zoom window is visible)</li>
              <li><b>Esc</b> — hide zoom (if visible) / close editor</li>
            </ul>
            <div class="waveShortcutsNote">Tip: <b>Snap</b> affects <b>Apply</b> (zero-crossing start).</div>
          </div>

        </div>
      </div>
    </div>
  </div>


  <!-- Column Split Editor Overlay -->
  <div class="overlay" id="splitOverlay" aria-hidden="true" style="display:none;">
    <div class="helpPanel wavePanel">
      <div class="helpHead">
        <div class="helpTitle" id="splitTitle">Slice Editor</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button class="helpClose" type="button" id="splitLoadBtn" title="Load a new sample for splitting">Load new</button>
          <button class="helpClose" type="button" id="splitAutoBtn" title="Auto tile 8 slices across the sample">Auto</button>
          <button class="helpClose" type="button" id="splitPlaySelBtn" title="Play focused slice (Space)">Play sel</button>
          <button class="helpClose" type="button" id="splitPlayFullBtn" title="Play full sample">Play all</button>
<button class="helpClose" type="button" id="splitUndoBtn" title="Undo last split edit" disabled>Undo</button>
          <button class="helpClose" type="button" id="splitApplyBtn" title="Apply splits into the column">Apply</button>
          <button class="helpClose" type="button" id="splitCloseBtn" title="Close" style="margin-left:8px;">Close</button>
        </div>
      </div>

      <div class="helpBody" style="padding:10px 12px;">
        <div class="waveWrap" id="splitBigWrap" style="position:relative;">
          <canvas id="splitBig" width="900" height="230" style="width:100%; height:230px;"></canvas>
        </div>
        <div class="waveEditorMeta" style="margin-top:8px;">
          <div class="kv"><span class="k">Name</span><span class="v" id="splitName">—</span></div>
          <div class="kv"><span class="k">Start</span><span class="v" id="splitSelStart">—</span></div>
          <div class="kv"><span class="k">Length</span><span class="v" id="splitSelLen">—</span></div>
          <div class="kv"><span class="k">Source</span><span class="v" id="splitSrcName">—</span></div>
        </div>
        <div class="muted" id="splitHint" style="margin-top:8px; font-size:12px;">Load a sample, then drag/resize the 8 blocks.<br><span class="muted"><b>Space</b>/<b>Play sel</b> = play/stop focused slice • <b>Play all</b> = play/stop full sample</span></div>
        <div class="waveShortcuts">
          <div class="waveShortcutsTitle">Shortcuts</div>
          <ul class="waveShortcutsList">
            <li><b>Space</b> — play focused slice</li>
            <li><b>← / →</b> — nudge focused slice</li>
            <li><b>Shift</b> + ← / → — coarse nudge</li>
            <li><b>Alt/Option</b> + ← / → — fine nudge</li>
            <li><b>L</b> / <b>M</b> / <b>R</b> — control Left edge / Move / Right edge (with zoom)</li>
            <li><b>+</b> / <b>-</b> — zoom window (when visible)</li>
            <li><b>Z</b> — auto-normalize (when zoom window is visible)</li>
            <li><b>Esc</b> — hide zoom (if visible) / close editor</li>
          </ul>
          <div class="waveShortcutsNote">Tip: <b>Auto</b> spreads all 8 slices evenly across the whole sample.</div>
        </div>

      </div>
    </div>
  </div>

  <!-- Magnifier (Phase 1: shows only while resizing handles in Wave/Split editors) -->
  <div id="tcmMag" class="tcmMag" style="display:none">
    <canvas id="tcmMagCv" width="420" height="200"></canvas>
    <div id="tcmMagLbl" class="tcmMagLbl"><span id="tcmMagLblTxt"></span><span id="zIndMag" class="z-indicator" title="Z: Auto-Norm">Z</span></div>
  </div>

</body>
</html>
